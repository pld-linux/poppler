diff -Nur poppler.0_5_0/ChangeLog poppler.HEAD/ChangeLog
--- poppler.0_5_0/ChangeLog	2006-01-11 17:52:58.000000000 +0100
+++ poppler.HEAD/ChangeLog	2006-02-23 23:26:05.000000000 +0100
@@ -1,3 +1,240 @@
+2006-02-23  Albert Astals Cid  <aacid@kde.org>
+
+	* utils/Makefile.am: Do not build pdftoppm when SplashOutputDev is
+	disabled as that does not work
+
+2006-02-18  Jeff Muizelaar  <jeff@infidigm.net>
+
+	* poppler/CairoOutputDev.cc:
+	* poppler/CairoOutputDev.h:
+	* poppler/GfxState.cc:
+	* poppler/GfxState.h: Add support for drawSoftMaskedImage to
+	CairoOutputDev. Ugly but works.
+
+2006-02-16  Jeff Muizelaar  <jeff@infidigm.net>
+
+	* poppler/CairoOutputDev.cc: Work around cairo bug when scaling
+	1x1 bitmaps. Fixes #3387. Also gives a performance improvement.
+
+2006-02-16  Albert Astals Cid  <aacid@kde.org>
+
+	* qt4/src/Makefile.am:
+	* qt/Makefile.am:
+	* poppler/Makefile.am:
+	* glib/Makefile.am: Update soname as we are not really compatible
+	anymore with previous releases that had soname 0.0.0
+
+2006-02-13  Albert Astals Cid  <aacid@kde.org>
+
+	* poppler/ArthurOutputDev.cc: Make it compile after changing code so
+	we did not pass files to freetype but buffers
+
+2006-02-13  Albert Astals Cid  <aacid@kde.org>
+
+	* poppler/PSOutputDev.cc: Commit setupExternalCIDTrueTypeFont patch
+	kpdf got from Takashi Iwai (SuSe) a long time ago
+
+2006-02-06  Albert Astals Cid  <aacid@kde.org>
+
+	* configure.ac:
+	* goo/FixedPoint.h:
+	* splash/Splash.cc:
+	* splash/SplashTypes.h: Various fixes from Frank Meerkötter to enable
+	fixedpoint arithmetic
+
+2006-02-06  Albert Astals Cid  <aacid@kde.org>
+	
+	* poppler/Annot.cc: Fix small leaks
+	* poppler/JBIG2Stream.cc: Remove check improving as really did not
+	improve anything
+	
+2006-02-05  Albert Astals Cid  <aacid@kde.org>
+
+	* poppler/Gfx.cc: Fix small leak
+	* poppler/GfxFont.cc: I needed that guard in kpdf to fix a crash and
+	it surely does not hurt
+	* poppler/JBIG2Stream.cc: Improve check (comes from kpdf)
+	* poppler/SplashOutputDev.cc: Unneeded var--
+
+2006-02-04  Jeff Muizelaar  <jeff@infidigm.net>
+
+	* poppler/Gfx.cc:
+	* poppler/OutputDev.cc:
+	* poppler/OutputDev.h: Let output devices know about pdf grouping
+	operators.
+	Patch by Thorkild Stray.
+
+2006-02-04  Jeff Muizelaar  <jeff@infidigm.net>
+
+	* poppler/GlobalParams.cc: Check all fonts returned by fontconfig.
+	Discard the ones that are not truetype or type1. Fixes #5758.
+	Patch by Ed Catmur.
+
+2006-02-04  Albert Astals Cid  <aacid@kde.org>
+
+	* utils/Makefile.am:
+	* utils/pdftoppm.cc: Actually create pdftoppm patch by Stefan
+	Schweizer
+	* utils/pdf2xml.dtd: Added a DTD of the xml pdftohtml creates patch by
+	Stefan Schweizer
+	* poppler/SplashOutputDev.cc: Remove bug from "do not use an external
+	file to pass fonts to Freetype" patch, patch by Stefan Schweizer
+		
+
+2006-02-02  Albert Astals Cid  <aacid@kde.org>
+
+	* splash/SplashXPathScanner.cc: CVE-2006-0301 fix by Derek (xpdf man
+	itslef) got though Dirk Mueller of KDE security team
+
+2006-02-02  Albert Astals Cid  <aacid@kde.org>
+
+	* fofi/FoFiTrueType.cc:
+	* fofi/FoFiTrueType.h:
+	* fofi/FoFiType1C.h:
+	* goo/gfile.cc:
+	* poppler/GfxFont.cc:
+	* poppler/GfxFont.h:
+	* poppler/GlobalParams.cc:
+	* poppler/GlobalParams.h:
+	* poppler/SplashOutputDev.cc:
+	* splash/SplashFTFontEngine.cc:
+	* splash/SplashFTFontEngine.h:
+	* splash/SplashFTFontFile.cc:
+	* splash/SplashFTFontFile.h:
+	* splash/SplashFontEngine.cc:
+	* splash/SplashFontEngine.h:
+	* splash/SplashFontFile.cc:
+	* splash/SplashFontFile.h:
+	* splash/SplashT1FontEngine.cc:
+	* splash/SplashT1FontFile.cc:
+	* splash/SplashT1FontFile.h: Merge patch to not use external file
+	  when passing the font to Freetype, original patch by Takashi Iwai
+	  adapted by me to kpdf rediffed by Stefan Schweizer against poppler
+	  cvs
+
+2006-01-31  Jeff Muizelaar  <jeff@infidigm.net>
+
+	* poppler/GlobalParams.cc (GlobalParams::getDisplayFont):
+	Allow ttc fonts to be used.
+
+2006-01-28  Jeff Muizelaar  <jeff@infidigm.net>
+
+	* glib/poppler-attachment.h: fix compile by adding <time.h> include.
+	Acked-by: Jonathan Blanford <jrb@redhat.com>
+
+2006-01-26  Kristian Høgsberg  <krh@redhat.com>
+
+	* poppler/CairoOutputDev.cc: Patch from Christian Krause; handle
+	0-width lines (#5545).
+
+Tue Jan 24 01:19:40 2006  Jonathan Blandford  <jrb@redhat.com>
+
+	* glib/Makefile.am:
+	* glib/poppler-attachment.cc:
+	* glib/poppler-attachment.h:
+	* glib/poppler-document.cc:
+	* glib/poppler-document.h:
+	* glib/poppler-page.cc:
+	* glib/poppler-private.h:
+	* glib/poppler.h:
+	* glib/test-poppler-glib.c:
+	* glib/reference/tmpl/poppler-enums.sgml:
+	* glib/reference/tmpl/poppler-unused.sgml: glib bindings for the
+	embedded file support.  It doesn't support mtime and ctime yet,
+	but the rest works.
+
+2006-01-23  Kristian Høgsberg  <krh@redhat.com>
+
+	* configure.ac:
+	* poppler/GlobalParams.cc:
+	* poppler/poppler-config.h.in:
+	* utils/pdftohtml.cc:
+	* utils/pdftops.cc: Respect command line paper size settings (#5641).
+	Drop the built-in paper sizes.
+
+2006-01-23  Kristian Høgsberg  <krh@redhat.com>
+
+	* glib/test-poppler-glib.c (print_document_info, print_index):
+	Move variable declarations to top (#5692).
+
+	* utils/*.cc: Move config.h #include to top of #include's (#5693).
+
+	* splash/SplashFTFont.cc: Don't use deprecated freetype include
+	files.
+
+2006-01-21  Jeff Muizelaar  <jeff@infidigm.net>
+
+	* TODO: Add my todo list.
+
+2006-01-18  Albert Astals Cid  <aacid@kde.org>
+
+	* glib/poppler-action.cc:
+	* glib/poppler-document.cc:
+	* poppler/Annot.cc:
+	* poppler/Catalog.cc:
+	* poppler/Catalog.h:
+	* poppler/Dict.cc:
+	* poppler/Dict.h:
+	* poppler/FontInfo.cc:
+	* poppler/Function.cc:
+	* poppler/Gfx.cc:
+	* poppler/GfxFont.cc:
+	* poppler/GfxState.cc:
+	* poppler/Link.cc:
+	* poppler/Link.h:
+	* poppler/Makefile.am:
+	* poppler/Object.h:
+	* poppler/Outline.cc:
+	* poppler/PDFDoc.cc:
+	* poppler/PDFDoc.h:
+	* poppler/PSOutputDev.cc:
+	* poppler/Page.cc:
+	* poppler/PageLabelInfo.cc:
+	* poppler/Parser.cc:
+	* poppler/SecurityHandler.cc:
+	* poppler/Stream.cc:
+	* poppler/XRef.cc:
+	* qt/poppler-document.cc:
+	* qt/poppler-page-transition.cc:
+	* qt4/src/Makefile.am:
+	* qt4/src/poppler-document.cc:
+	* qt4/src/poppler-private.h:
+	* qt4/src/poppler-qt4.h:
+	* qt4/tests/Makefile.am:
+	* utils/HtmlOutputDev.cc:
+	* utils/pdffonts.cc:
+	* utils/pdfinfo.cc:
+	* utils/pdftohtml.cc:
+	* utils/pdftotext.cc: Brad patch for embedded document extraction,
+	only has Qt4 bindings for now, needs Qt3 and glib work
+
+2006-01-18  Albert Astals Cid  <aacid@kde.org>
+
+	* qt/poppler-page-transition.h:
+	* qt4/src/Doxyfile: Add some more documentation to PageTransition,
+	patch by Stefan Kebekus
+
+2006-01-18  Albert Astals Cid  <aacid@kde.org>
+
+	* poppler/CharCodeToUnicode.cc: Fix check for length that was not
+	having into account that there could be \n or \r in tokens an that
+	those do not have to be took into account. Fixes
+	http://bugs.kde.org/show_bug.cgi?id=120310
+
+2006-01-17  Albert Astals Cid  <aacid@kde.org>
+
+	* poppler/Lexer.cc:
+	* poppler/Lexer.h:
+	* poppler/Parser.cc:
+	* poppler/Parser.h:
+	* poppler/XRef.cc:
+	* poppler/XRef.h: When doing the parsing check with XREF we did not
+	grow too much. Fixes serialata10a.pdf
+
+2006-01-12  Jeff Muizelaar  <jeff@infidigm.net>
+
+	* poppler/GlobalParams.cc: Make buildFcPattern() static.
+
 2006-01-11  Kristian Høgsberg  <krh@redhat.com>
 
 	* poppler/JBIG2Stream.cc:
diff -Nur poppler.0_5_0/configure.ac poppler.HEAD/configure.ac
--- poppler.0_5_0/configure.ac	2006-01-06 11:05:58.000000000 +0100
+++ poppler.HEAD/configure.ac	2006-02-06 21:49:21.000000000 +0100
@@ -17,7 +17,6 @@
 AC_CHECK_FUNC(gettimeofday, AC_DEFINE(HAVE_GETTIMEOFDAY, 1, [Defines if gettimeofday is available on your system]))
 
 dnl Enable these unconditionally.
-AC_DEFINE([A4_PAPER], [1], [Default to A4 paper.])
 AC_DEFINE([OPI_SUPPORT], [1], [Generate OPI comments in PS output.])
 AC_DEFINE([MULTITHREADED], [1], [Enable multithreading support.])
 AC_DEFINE([TEXTOUT_WORD_LIST], [1], [Enable word list support.])
@@ -32,7 +31,7 @@
 
 AC_ARG_ENABLE(fixedpoint,
 [  --enable-fixedpoint     use fixed point (instead of floating point) arithmetic],
-AC_DEFINE(USE_FIXEDPOINT, [], [Use fixed point arithmetic]))
+AC_DEFINE(USE_FIXEDPOINT, [1], [Use fixed point arithmetic]))
 
 dnl ##### Path to xpdfrc.
 dnl This ugly kludge to get the sysconfdir path is needed because
@@ -243,19 +242,13 @@
 AM_CONDITIONAL(BUILD_POPPLER_QT4, test x$enable_poppler_qt4 = xyes)
 
 if test x$enable_poppler_qt4 = xyes; then
-  POPPLER_FIND_QT4TEST(POPPLER_QTTEST)
+  POPPLER_FIND_QT4TEST(POPPLER_QTTEST,
+                      [enable_poppler_qt4testlib="yes"],
+                      [enable_poppler_qt4testlib="no"])
   AC_SUBST(POPPLER_QTTEST_CXXFLAGS)
   AC_SUBST(POPPLER_QTTEST_LIBS)
-fi
-
-if test x$have_qt4testlib = xno ; then
-    AC_MSG_WARN([QtTestLib libraries not found])
-fi
-
-if test x$have_qt4testlib = xyes; then
-    enable_poppler_qt4testlib="yes"
 else
-    enable_poppler_qt4testlib="no"
+  enable_poppler_qt4testlib="no"
 fi
 
 AM_CONDITIONAL(BUILD_POPPLER_QT4TESTS, test x$enable_poppler_qt4testlib = xyes)
diff -Nur poppler.0_5_0/fofi/FoFiTrueType.cc poppler.HEAD/fofi/FoFiTrueType.cc
--- poppler.0_5_0/fofi/FoFiTrueType.cc	2005-09-14 23:20:36.000000000 +0200
+++ poppler.HEAD/fofi/FoFiTrueType.cc	2006-02-02 23:50:01.000000000 +0100
@@ -241,10 +241,10 @@
 // FoFiTrueType
 //------------------------------------------------------------------------
 
-FoFiTrueType *FoFiTrueType::make(char *fileA, int lenA) {
+FoFiTrueType *FoFiTrueType::make(char *fileA, int lenA, int faceIndexA) {
   FoFiTrueType *ff;
 
-  ff = new FoFiTrueType(fileA, lenA, gFalse);
+  ff = new FoFiTrueType(fileA, lenA, gFalse, faceIndexA);
   if (!ff->parsedOk) {
     delete ff;
     return NULL;
@@ -252,7 +252,7 @@
   return ff;
 }
 
-FoFiTrueType *FoFiTrueType::load(char *fileName) {
+FoFiTrueType *FoFiTrueType::load(char *fileName, int faceIndexA) {
   FoFiTrueType *ff;
   char *fileA;
   int lenA;
@@ -260,7 +260,7 @@
   if (!(fileA = FoFiBase::readFile(fileName, &lenA))) {
     return NULL;
   }
-  ff = new FoFiTrueType(fileA, lenA, gTrue);
+  ff = new FoFiTrueType(fileA, lenA, gTrue, faceIndexA);
   if (!ff->parsedOk) {
     delete ff;
     return NULL;
@@ -268,7 +268,7 @@
   return ff;
 }
 
-FoFiTrueType::FoFiTrueType(char *fileA, int lenA, GBool freeFileDataA):
+FoFiTrueType::FoFiTrueType(char *fileA, int lenA, GBool freeFileDataA, int faceIndexA):
   FoFiBase(fileA, lenA, freeFileDataA)
 {
   tables = NULL;
@@ -277,6 +277,7 @@
   nCmaps = 0;
   nameToGID = NULL;
   parsedOk = gFalse;
+  faceIndex = faceIndexA;
 
   parse();
 }
@@ -1535,9 +1536,12 @@
   return checksum;
 }
 
+#define toTag(a,b,c,d) (((unsigned int)(a)<<24) | ((unsigned int)(b)<<16) | ((unsigned int)(c)<<8) | (d))
+
 void FoFiTrueType::parse() {
   Guint topTag;
   int pos, i, j;
+  unsigned int head;
 
   parsedOk = gTrue;
 
@@ -1556,12 +1560,37 @@
   }
 
   // read the table directory
-  nTables = getU16BE(pos + 4, &parsedOk);
+  head = getU32BE(pos, &parsedOk);
+  if (! parsedOk)
+    return;
+  if (head == toTag('t','t','c','f')) {
+    /* TTC font */
+    unsigned int tableDir;
+    int dircount;
+
+    dircount = getU32BE(8, &parsedOk);
+    if (!parsedOk)
+      return;
+    if (! dircount) {
+      parsedOk = gFalse;
+      return;
+    }
+
+    if (faceIndex >= dircount)
+      faceIndex = 0;
+    pos = getU32BE(12 + faceIndex * 4, &parsedOk);
+    if (! parsedOk)
+      return;
+  }
+
+  pos += 4;
+  nTables = getU16BE(pos, &parsedOk);
   if (!parsedOk) {
     return;
   }
+
+  pos += 8;
   tables = (TrueTypeTable *)gmallocn(nTables, sizeof(TrueTypeTable));
-  pos += 12;
   for (i = 0; i < nTables; ++i) {
     tables[i].tag = getU32BE(pos, &parsedOk);
     tables[i].checksum = getU32BE(pos + 4, &parsedOk);
diff -Nur poppler.0_5_0/fofi/FoFiTrueType.h poppler.HEAD/fofi/FoFiTrueType.h
--- poppler.0_5_0/fofi/FoFiTrueType.h	2005-09-14 23:20:36.000000000 +0200
+++ poppler.HEAD/fofi/FoFiTrueType.h	2006-02-02 23:50:01.000000000 +0100
@@ -29,11 +29,12 @@
 public:
 
   // Create a FoFiTrueType object from a memory buffer.
-  static FoFiTrueType *make(char *fileA, int lenA);
+  static FoFiTrueType *make(char *fileA, int lenA, int faceIndexA=0);
 
   // Create a FoFiTrueType object from a file on disk.
-  static FoFiTrueType *load(char *fileName);
+  static FoFiTrueType *load(char *fileName, int faceIndexA=0);
 
+  FoFiTrueType(char *fileA, int lenA, GBool freeFileDataA, int faceIndexA=0);
   virtual ~FoFiTrueType();
 
   // Return the number of cmaps defined by this font.
@@ -104,7 +105,6 @@
 
 private:
 
-  FoFiTrueType(char *fileA, int lenA, GBool freeFileDataA);
   void cvtEncoding(char **encoding,
 		   FoFiOutputFunc outputFunc,
 		   void *outputStream);
@@ -133,6 +133,7 @@
   GooHash *nameToGID;
 
   GBool parsedOk;
+  int faceIndex;
 };
 
 #endif
diff -Nur poppler.0_5_0/fofi/FoFiType1C.h poppler.HEAD/fofi/FoFiType1C.h
--- poppler.0_5_0/fofi/FoFiType1C.h	2005-09-14 23:20:36.000000000 +0200
+++ poppler.HEAD/fofi/FoFiType1C.h	2006-02-02 23:50:01.000000000 +0100
@@ -138,6 +138,7 @@
   // Create a FoFiType1C object from a file on disk.
   static FoFiType1C *load(char *fileName);
 
+  FoFiType1C(char *fileA, int lenA, GBool freeFileDataA);
   virtual ~FoFiType1C();
 
   // Return the font name.
@@ -173,7 +174,6 @@
 
 private:
 
-  FoFiType1C(char *fileA, int lenA, GBool freeFileDataA);
   void eexecCvtGlyph(Type1CEexecBuf *eb, char *glyphName,
 		     int offset, int nBytes,
 		     Type1CIndex *subrIdx,
diff -Nur poppler.0_5_0/glib/Makefile.am poppler.HEAD/glib/Makefile.am
--- poppler.0_5_0/glib/Makefile.am	2006-01-02 01:06:46.000000000 +0100
+++ poppler.HEAD/glib/Makefile.am	2006-02-16 20:28:54.000000000 +0100
@@ -58,6 +58,7 @@
 	poppler-action.h			\
 	poppler-document.h			\
 	poppler-page.h				\
+	poppler-attachment.h			\
 	poppler.h
 
 poppler_glib_includedir = $(includedir)/poppler/glib
@@ -72,6 +73,7 @@
 	poppler-action.cc			\
 	poppler-document.cc			\
 	poppler-page.cc				\
+	poppler-attachment.cc			\
 	poppler.cc				\
 	poppler-private.h
 
@@ -81,6 +83,8 @@
 	$(FREETYPE_LIBS)			\
 	$(cairo_libs)
 
+libpoppler_glib_la_LDFLAGS = -version-info 1:0:0
+
 noinst_PROGRAMS = test-poppler-glib
 
 test_poppler_glib_SOURCES =			\
diff -Nur poppler.0_5_0/glib/poppler-action.cc poppler.HEAD/glib/poppler-action.cc
--- poppler.0_5_0/glib/poppler-action.cc	2005-12-31 03:10:33.000000000 +0100
+++ poppler.HEAD/glib/poppler-action.cc	2006-01-18 23:32:13.000000000 +0100
@@ -182,7 +182,7 @@
 		 LinkGoTo        *link)
 {
 	LinkDest *link_dest;
-	GooString *named_dest;
+	UGooString *named_dest;
 
 	/* Return if it isn't OK */
 	if (! link->isOk ()) {
diff -Nur poppler.0_5_0/glib/poppler-attachment.cc poppler.HEAD/glib/poppler-attachment.cc
--- poppler.0_5_0/glib/poppler-attachment.cc	1970-01-01 01:00:00.000000000 +0100
+++ poppler.HEAD/glib/poppler-attachment.cc	2006-01-24 07:21:39.000000000 +0100
@@ -0,0 +1,223 @@
+/* poppler-attachment.cc: glib wrapper for poppler
+ * Copyright (C) 2006, Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <errno.h>
+#include <glib/gstdio.h>
+
+#include "poppler.h"
+#include "poppler-private.h"
+#include "poppler-attachment.h"
+
+/* FIXME: We need to add gettext support sometime */
+#define _(x) (x)
+
+typedef struct _PopplerAttachmentPrivate PopplerAttachmentPrivate;
+struct _PopplerAttachmentPrivate
+{
+  Object obj_stream;
+};
+
+#define POPPLER_ATTACHMENT_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), POPPLER_TYPE_ATTACHMENT, PopplerAttachmentPrivate))
+
+static void poppler_attachment_finalize (GObject *obj);
+
+G_DEFINE_TYPE (PopplerAttachment, poppler_attachment, G_TYPE_OBJECT);
+
+static void
+poppler_attachment_init (PopplerAttachment *attachment)
+{
+
+}
+
+static void
+poppler_attachment_class_init (PopplerAttachmentClass *klass)
+{
+  G_OBJECT_CLASS (klass)->finalize = poppler_attachment_finalize;
+  g_type_class_add_private (klass, sizeof (PopplerAttachmentPrivate));
+}
+
+static void
+poppler_attachment_finalize (GObject *obj)
+{
+  PopplerAttachment *attachment;
+
+  attachment = (PopplerAttachment *) obj;
+  POPPLER_ATTACHMENT_GET_PRIVATE (attachment)->obj_stream.free();
+}
+
+/* Public functions */
+
+PopplerAttachment *
+_poppler_attachment_new (PopplerDocument *document,
+			 EmbFile         *emb_file)
+{
+  PopplerAttachment *attachment;
+
+  g_assert (document != NULL);
+  g_assert (emb_file != NULL);
+
+  attachment = (PopplerAttachment *) g_object_new (POPPLER_TYPE_ATTACHMENT, NULL);
+  
+  if (emb_file->name ())
+    attachment->name = g_strdup (emb_file->name ()->getCString ());
+  if (emb_file->description ())
+    attachment->description = g_strdup (emb_file->description ()->getCString ());
+
+  emb_file->streamObject().copy(&POPPLER_ATTACHMENT_GET_PRIVATE (attachment)->obj_stream);
+
+  return attachment;
+}
+
+static gboolean
+save_helper (const gchar  *buf,
+	     gsize         count,
+	     gpointer      data,
+	     GError      **error)
+{
+  FILE *f = (FILE *) data;
+  gsize n;
+
+  n = fwrite (buf, 1, count, f);
+  if (n != count)
+    {
+      g_set_error (error,
+		   G_FILE_ERROR,
+		   g_file_error_from_errno (errno),
+		   _("Error writing to image file: %s"),
+		   g_strerror (errno));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/**
+ * poppler_attachment_save:
+ * @attachment: A #PopplerAttachment.
+ * @filename: name of file to save
+ * @error: return location for error, or %NULL.
+ * 
+ * Saves @attachment to a file indicated by @filename.  If @error is set, %FALSE
+ * will be returned. Possible errors include those in the #G_FILE_ERROR domain
+ * and whatever the save function generates.
+ * 
+ * Return value: %TRUE, if the file successfully saved
+ **/
+gboolean
+poppler_attachment_save (PopplerAttachment  *attachment,
+			 const char         *filename,
+			 GError            **error)
+{
+  gboolean result;
+  FILE *f;
+  
+  g_return_val_if_fail (POPPLER_IS_ATTACHMENT (attachment), FALSE);
+
+  f = g_fopen (filename, "wb");
+
+  if (f == NULL)
+    {
+      gchar *display_name = g_filename_display_name (filename);
+      g_set_error (error,
+		   G_FILE_ERROR,
+		   g_file_error_from_errno (errno),
+		   _("Failed to open '%s' for writing: %s"),
+		   display_name,
+		   g_strerror (errno));
+      g_free (display_name);
+      return FALSE;
+    }
+
+  result = poppler_attachment_save_to_callback (attachment, save_helper, f, error);
+
+  if (fclose (f) < 0)
+    {
+      gchar *display_name = g_filename_display_name (filename);
+      g_set_error (error,
+		   G_FILE_ERROR,
+		   g_file_error_from_errno (errno),
+		   _("Failed to close '%s', all data may not have been saved: %s"),
+		   display_name,
+		   g_strerror (errno));
+      g_free (display_name);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+#define BUF_SIZE 1024
+
+/**
+ * poppler_attachment_save_to_callback:
+ * @attachment: A #GdkPixbuf.
+ * @save_func: a function that is called to save each block of data that the save routine generates.
+ * @user_data: user data to pass to the save function.
+ * @error: return location for error, or %NULL.
+ * 
+ * Saves @attachment by feeding the produced data to @save_func. Can be used
+ * when you want to store the attachment to something other than a file, such as
+ * an in-memory buffer or a socket. If @error is set, %FALSE will be
+ * returned. Possible errors include those in the #G_FILE_ERROR domain and
+ * whatever the save function generates.
+ * 
+ * Return value: %TRUE, if the save successfully completed
+ **/
+gboolean
+poppler_attachment_save_to_callback (PopplerAttachment          *attachment,
+				     PopplerAttachmentSaveFunc   save_func,
+				     gpointer                    user_data,
+				     GError                    **error)
+{
+  Stream *stream;
+  gchar buf[BUF_SIZE]; 
+  int i;
+  gboolean eof_reached = FALSE;
+
+  g_return_val_if_fail (POPPLER_IS_ATTACHMENT (attachment), FALSE);
+
+  stream = POPPLER_ATTACHMENT_GET_PRIVATE (attachment)->obj_stream.getStream();
+  stream->reset();
+
+  do
+    {
+      int data;
+
+      for (i = 0; i < BUF_SIZE; i++)
+	{
+	  data = stream->getChar ();
+	  if (data == EOF)
+	    {
+	      eof_reached = TRUE;
+	      break;
+	    }
+	  buf[i] = data;
+	}
+
+      if (i > 0)
+	{
+	  if (! (save_func) (buf, i, user_data, error))
+	    return FALSE;
+	}
+    }
+  while (! eof_reached);
+
+
+  return TRUE;
+}
diff -Nur poppler.0_5_0/glib/poppler-attachment.h poppler.HEAD/glib/poppler-attachment.h
--- poppler.0_5_0/glib/poppler-attachment.h	1970-01-01 01:00:00.000000000 +0100
+++ poppler.HEAD/glib/poppler-attachment.h	2006-01-29 06:16:31.000000000 +0100
@@ -0,0 +1,68 @@
+/* poppler-attachment.h: glib interface to poppler
+ * Copyright (C) 2004, Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __POPPLER_ATTACHMENT_H__
+#define __POPPLER_ATTACHMENT_H__
+
+#include <time.h>
+#include <glib-object.h>
+
+#include "poppler.h"
+
+G_BEGIN_DECLS
+
+
+#define POPPLER_TYPE_ATTACHMENT             (poppler_attachment_get_type ())
+#define POPPLER_ATTACHMENT(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), POPPLER_TYPE_ATTACHMENT, PopplerAttachment))
+#define POPPLER_IS_ATTACHMENT(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), POPPLER_TYPE_ATTACHMENT))
+
+
+typedef gboolean (*PopplerAttachmentSaveFunc) (const gchar  *buf,
+					       gsize         count,
+					       gpointer      data,
+					       GError      **error);
+
+typedef struct _PopplerAttachment
+{
+  GObject parent;
+
+  const char *name;
+  const char *description;
+  time_t mtime;
+  time_t ctime;
+} PopplerAttachment;
+
+typedef struct _PopplerAttachmentClass
+{
+  GObjectClass parent_class;
+} PopplerAttachmentClass;
+
+
+GType     poppler_attachment_get_type         (void) G_GNUC_CONST;
+gboolean  poppler_attachment_save             (PopplerAttachment          *attachment,
+					       const char                 *filename,
+					       GError                    **error);
+gboolean  poppler_attachment_save_to_callback (PopplerAttachment          *attachment,
+					       PopplerAttachmentSaveFunc   save_func,
+					       gpointer                    user_data,
+					       GError                    **error);
+
+
+G_END_DECLS
+
+#endif /* __POPPLER_ATTACHMENT_H__ */
diff -Nur poppler.0_5_0/glib/poppler-document.cc poppler.HEAD/glib/poppler-document.cc
--- poppler.0_5_0/glib/poppler-document.cc	2005-12-31 03:10:33.000000000 +0100
+++ poppler.HEAD/glib/poppler-document.cc	2006-01-24 07:21:39.000000000 +0100
@@ -28,9 +28,11 @@
 #include <Stream.h>
 #include <FontInfo.h>
 #include <PDFDocEncoding.h>
+#include <UGooString.h>
 
 #include "poppler.h"
 #include "poppler-private.h"
+#include "poppler-attachment.h"
 #include "poppler-enums.h"
 
 enum {
@@ -251,6 +253,68 @@
   return poppler_document_get_page (document, index);
 }
 
+/**
+ * poppler_document_has_attachments:
+ * @document: A #PopplerDocument
+ * 
+ * Returns %TRUE of @document has any attachments.
+ * 
+ * Return value: %TRUE, if @document has attachments.
+ **/
+gboolean
+poppler_document_has_attachments (PopplerDocument *document)
+{
+  Catalog *catalog;
+  int n_files = 0;
+
+  g_return_val_if_fail (POPPLER_IS_DOCUMENT (document), FALSE);
+
+  catalog = document->doc->getCatalog ();
+  if (catalog && catalog->isOk ())
+    {
+      n_files = catalog->numEmbeddedFiles ();
+    }
+
+  return (n_files != 0);
+}
+
+/**
+ * poppler_document_get_attachments:
+ * @document: A #PopplerDocument
+ * 
+ * Returns a #GList containing #PopplerAttachment<!-- -->s.  These attachments
+ * are unowned, and must be unreffed, and the list must be freed with
+ * g_list_free().
+ * 
+ * Return value: a list of available attachments.
+ **/
+GList *
+poppler_document_get_attachments (PopplerDocument *document)
+{
+  Catalog *catalog;
+  int n_files, i;
+  GList *retval = NULL;
+
+  g_return_val_if_fail (POPPLER_IS_DOCUMENT (document), NULL);
+
+  catalog = document->doc->getCatalog ();
+  if (catalog == NULL || ! catalog->isOk ())
+    return NULL;
+
+  n_files = catalog->numEmbeddedFiles ();
+  for (i = 0; i < n_files; i++)
+    {
+      PopplerAttachment *attachment;
+      EmbFile *emb_file;
+
+      emb_file = catalog->embeddedFile (i);
+      attachment = _poppler_attachment_new (document, emb_file);
+
+      retval = g_list_prepend (retval, attachment);
+    }
+  return g_list_reverse (retval);
+}
+
 static gboolean
 has_unicode_marker (GooString *string)
 {
diff -Nur poppler.0_5_0/glib/poppler-document.h poppler.HEAD/glib/poppler-document.h
--- poppler.0_5_0/glib/poppler-document.h	2005-12-31 03:10:33.000000000 +0100
+++ poppler.HEAD/glib/poppler-document.h	2006-01-24 07:21:39.000000000 +0100
@@ -100,6 +100,10 @@
 						     int               index);
 PopplerPage     *poppler_document_get_page_by_label (PopplerDocument  *document,
 						     const char       *label);
+/* Attachments */
+gboolean         poppler_document_has_attachments   (PopplerDocument  *document);
+GList           *poppler_document_get_attachments   (PopplerDocument  *document);
+
 
 
 /* Interface for getting the Index of a poppler_document */
@@ -142,6 +146,8 @@
                                                gboolean         duplex);
 void           poppler_ps_file_free           (PopplerPSFile   *ps_file);
 
+
+
 G_END_DECLS
 
 #endif /* __POPPLER_DOCUMENT_H__ */
diff -Nur poppler.0_5_0/glib/poppler.h poppler.HEAD/glib/poppler.h
--- poppler.0_5_0/glib/poppler.h	2005-06-20 19:58:38.000000000 +0200
+++ poppler.HEAD/glib/poppler.h	2006-01-24 07:21:39.000000000 +0100
@@ -69,5 +69,6 @@
 #include "poppler-page.h"
 #include "poppler-action.h"
 #include "poppler-enums.h"
+#include "poppler-attachment.h"
 
 #endif /* __POPPLER_GLIB_H__ */
diff -Nur poppler.0_5_0/glib/poppler-page.cc poppler.HEAD/glib/poppler-page.cc
--- poppler.0_5_0/glib/poppler-page.cc	2005-12-31 03:10:33.000000000 +0100
+++ poppler.HEAD/glib/poppler-page.cc	2006-01-24 07:21:39.000000000 +0100
@@ -1,4 +1,4 @@
-/* poppler.h: glib wrapper for poppler
+/* poppler-page.cc: glib wrapper for poppler
  * Copyright (C) 2005, Red Hat, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
diff -Nur poppler.0_5_0/glib/poppler-private.h poppler.HEAD/glib/poppler-private.h
--- poppler.0_5_0/glib/poppler-private.h	2005-08-22 20:20:12.000000000 +0200
+++ poppler.HEAD/glib/poppler-private.h	2006-01-24 07:21:39.000000000 +0100
@@ -8,6 +8,9 @@
 #include <Gfx.h>
 #include <FontInfo.h>
 #include <TextOutputDev.h>
+#include <Catalog.h>
+
+#include "poppler-attachment.h"
 
 #if defined (HAVE_CAIRO)
 #include <CairoOutputDev.h>
@@ -62,5 +65,6 @@
 				    LinkAction      *link,
 				    const gchar     *title);
 
-
+PopplerAttachment *_poppler_attachment_new (PopplerDocument *document,
+					    EmbFile         *file);
 #endif
diff -Nur poppler.0_5_0/glib/reference/tmpl/poppler-enums.sgml poppler.HEAD/glib/reference/tmpl/poppler-enums.sgml
--- poppler.0_5_0/glib/reference/tmpl/poppler-enums.sgml	2006-01-06 11:05:58.000000000 +0100
+++ poppler.HEAD/glib/reference/tmpl/poppler-enums.sgml	2006-01-24 07:21:39.000000000 +0100
@@ -17,3 +17,153 @@
 <!-- ##### SECTION Stability_Level ##### -->
 
 
+<!-- ##### MACRO POPPLER_TYPE_ACTION_TYPE ##### -->
+<para>
+
+</para>
+
+
+
+<!-- ##### FUNCTION poppler_action_type_get_type ##### -->
+<para>
+
+</para>
+
+@Returns: 
+
+
+<!-- ##### MACRO POPPLER_TYPE_DEST_TYPE ##### -->
+<para>
+
+</para>
+
+
+
+<!-- ##### FUNCTION poppler_dest_type_get_type ##### -->
+<para>
+
+</para>
+
+@Returns: 
+
+
+<!-- ##### MACRO POPPLER_TYPE_PAGE_LAYOUT ##### -->
+<para>
+
+</para>
+
+
+
+<!-- ##### FUNCTION poppler_page_layout_get_type ##### -->
+<para>
+
+</para>
+
+@Returns: 
+
+
+<!-- ##### MACRO POPPLER_TYPE_PAGE_MODE ##### -->
+<para>
+
+</para>
+
+
+
+<!-- ##### FUNCTION poppler_page_mode_get_type ##### -->
+<para>
+
+</para>
+
+@Returns: 
+
+
+<!-- ##### MACRO POPPLER_TYPE_FONT_TYPE ##### -->
+<para>
+
+</para>
+
+
+
+<!-- ##### FUNCTION poppler_font_type_get_type ##### -->
+<para>
+
+</para>
+
+@Returns: 
+
+
+<!-- ##### MACRO POPPLER_TYPE_VIEWER_PREFERENCES ##### -->
+<para>
+
+</para>
+
+
+
+<!-- ##### FUNCTION poppler_viewer_preferences_get_type ##### -->
+<para>
+
+</para>
+
+@Returns: 
+
+
+<!-- ##### MACRO POPPLER_TYPE_PERMISSIONS ##### -->
+<para>
+
+</para>
+
+
+
+<!-- ##### FUNCTION poppler_permissions_get_type ##### -->
+<para>
+
+</para>
+
+@Returns: 
+
+
+<!-- ##### MACRO POPPLER_TYPE_ERROR ##### -->
+<para>
+
+</para>
+
+
+
+<!-- ##### FUNCTION poppler_error_get_type ##### -->
+<para>
+
+</para>
+
+@Returns: 
+
+
+<!-- ##### MACRO POPPLER_TYPE_ORIENTATION ##### -->
+<para>
+
+</para>
+
+
+
+<!-- ##### FUNCTION poppler_orientation_get_type ##### -->
+<para>
+
+</para>
+
+@Returns: 
+
+
+<!-- ##### MACRO POPPLER_TYPE_BACKEND ##### -->
+<para>
+
+</para>
+
+
+
+<!-- ##### FUNCTION poppler_backend_get_type ##### -->
+<para>
+
+</para>
+
+@Returns: 
+
+
diff -Nur poppler.0_5_0/glib/reference/tmpl/poppler-unused.sgml poppler.HEAD/glib/reference/tmpl/poppler-unused.sgml
--- poppler.0_5_0/glib/reference/tmpl/poppler-unused.sgml	2006-01-06 11:05:58.000000000 +0100
+++ poppler.HEAD/glib/reference/tmpl/poppler-unused.sgml	2006-01-24 07:21:39.000000000 +0100
@@ -1,130 +0,0 @@
-<!-- ##### MACRO POPPLER_TYPE_ACTION_TYPE ##### -->
-<para>
-
-</para>
-
-
-<!-- ##### MACRO POPPLER_TYPE_BACKEND ##### -->
-<para>
-
-</para>
-
-
-<!-- ##### MACRO POPPLER_TYPE_DEST_TYPE ##### -->
-<para>
-
-</para>
-
-
-<!-- ##### MACRO POPPLER_TYPE_ERROR ##### -->
-<para>
-
-</para>
-
-
-<!-- ##### MACRO POPPLER_TYPE_FONT_TYPE ##### -->
-<para>
-
-</para>
-
-
-<!-- ##### MACRO POPPLER_TYPE_ORIENTATION ##### -->
-<para>
-
-</para>
-
-
-<!-- ##### MACRO POPPLER_TYPE_PAGE_LAYOUT ##### -->
-<para>
-
-</para>
-
-
-<!-- ##### MACRO POPPLER_TYPE_PAGE_MODE ##### -->
-<para>
-
-</para>
-
-
-<!-- ##### MACRO POPPLER_TYPE_PERMISSIONS ##### -->
-<para>
-
-</para>
-
-
-<!-- ##### MACRO POPPLER_TYPE_VIEWER_PREFERENCES ##### -->
-<para>
-
-</para>
-
-
-<!-- ##### FUNCTION poppler_action_type_get_type ##### -->
-<para>
-
-</para>
-
-@Returns: 
-
-<!-- ##### FUNCTION poppler_backend_get_type ##### -->
-<para>
-
-</para>
-
-@Returns: 
-
-<!-- ##### FUNCTION poppler_dest_type_get_type ##### -->
-<para>
-
-</para>
-
-@Returns: 
-
-<!-- ##### FUNCTION poppler_error_get_type ##### -->
-<para>
-
-</para>
-
-@Returns: 
-
-<!-- ##### FUNCTION poppler_font_type_get_type ##### -->
-<para>
-
-</para>
-
-@Returns: 
-
-<!-- ##### FUNCTION poppler_orientation_get_type ##### -->
-<para>
-
-</para>
-
-@Returns: 
-
-<!-- ##### FUNCTION poppler_page_layout_get_type ##### -->
-<para>
-
-</para>
-
-@Returns: 
-
-<!-- ##### FUNCTION poppler_page_mode_get_type ##### -->
-<para>
-
-</para>
-
-@Returns: 
-
-<!-- ##### FUNCTION poppler_permissions_get_type ##### -->
-<para>
-
-</para>
-
-@Returns: 
-
-<!-- ##### FUNCTION poppler_viewer_preferences_get_type ##### -->
-<para>
-
-</para>
-
-@Returns: 
-
diff -Nur poppler.0_5_0/glib/test-poppler-glib.c poppler.HEAD/glib/test-poppler-glib.c
--- poppler.0_5_0/glib/test-poppler-glib.c	2005-12-31 03:10:33.000000000 +0100
+++ poppler.HEAD/glib/test-poppler-glib.c	2006-01-24 07:21:39.000000000 +0100
@@ -13,11 +13,12 @@
   do
     {
       PopplerAction *action;
+      PopplerIndexIter *child;
 
       action = poppler_index_iter_get_action (iter);
       g_print ("Action: %d\n", action->type);
       poppler_action_free (action);
-      PopplerIndexIter *child = poppler_index_iter_get_child (iter);
+      child = poppler_index_iter_get_child (iter);
       if (child)
 	print_index (child);
       poppler_index_iter_free (child);
@@ -35,6 +36,7 @@
   PopplerViewerPreferences view_prefs;
   PopplerFontInfo *font_info;
   PopplerFontsIter *fonts_iter;
+  PopplerIndexIter *index_iter;
   GEnumValue *enum_value;
 
   g_object_get (document,
@@ -85,7 +87,6 @@
   }
   poppler_font_info_free (font_info);
 
-  PopplerIndexIter *index_iter;
   index_iter = poppler_index_iter_new (document);
   if (index_iter)
     {
@@ -197,7 +198,31 @@
 
       printf ("  (%f,%f)-(%f,%f)\n", rect->x1, rect->y1, rect->x2, rect->y2);
     }
-    
+
+  if (poppler_document_has_attachments (document))
+    {
+      int i = 0;
+
+      g_print ("Attachments found:\n\n");
+
+      list = poppler_document_get_attachments (document);
+      for (l = list; l; l = l->next)
+	{
+	  PopplerAttachment *attachment;
+	  char *name;
+
+	  name = g_strdup_printf ("/tmp/attach%d", i);
+	  attachment = l->data;
+	  g_print ("\tname: %s\n", attachment->name);
+	  g_print ("\tdescription: %s\n\n", attachment->description);
+	  poppler_attachment_save (attachment, name, NULL);
+	  i++;
+	}
+      g_list_foreach (list, g_object_unref, NULL);
+      g_list_free (list);
+    }
+  else
+    g_print ("no attachment\n");
 
   g_object_unref (G_OBJECT (page));
 
diff -Nur poppler.0_5_0/goo/FixedPoint.h poppler.HEAD/goo/FixedPoint.h
--- poppler.0_5_0/goo/FixedPoint.h	2005-09-16 20:29:18.000000000 +0200
+++ poppler.HEAD/goo/FixedPoint.h	2006-02-06 21:49:21.000000000 +0100
@@ -11,7 +11,7 @@
 #ifndef FIXEDPOINT_H
 #define FIXEDPOINT_H
 
-#include <aconf.h>
+#include <config.h>
 
 #if USE_FIXEDPOINT
 
diff -Nur poppler.0_5_0/goo/gfile.cc poppler.HEAD/goo/gfile.cc
--- poppler.0_5_0/goo/gfile.cc	2005-03-03 20:45:58.000000000 +0100
+++ poppler.HEAD/goo/gfile.cc	2006-02-02 23:50:01.000000000 +0100
@@ -489,6 +489,14 @@
     }
     (*name)->append("/XXXXXX")->append(ext);
     fd = mkstemps((*name)->getCString(), strlen(ext));
+#elif defined(HAVE_MKSTEMP)
+    if ((s = getenv("TMPDIR"))) {
+      *name = new GooString(s);
+    } else {
+      *name = new GooString("/tmp");
+    }
+    (*name)->append("/XXXXXX")->append(ext);
+    fd = mkstemp((*name)->getCString());
 #else
     if (!(s = tmpnam(NULL))) {
       return gFalse;
diff -Nur poppler.0_5_0/m4/qt.m4 poppler.HEAD/m4/qt.m4
--- poppler.0_5_0/m4/qt.m4	2006-01-06 11:05:58.000000000 +0100
+++ poppler.HEAD/m4/qt.m4	2006-01-10 22:57:28.000000000 +0100
@@ -156,6 +156,11 @@
 qt4_incdirs="/usr/local/qt/include /usr/include/qt4 /usr/include/qt /usr/include /usr/X11R6/include/X11/qt /usr/X11R6/include/qt /usr/lib/qt/include"
 qt4_libdirs="/usr/local/qt/lib /usr/lib/qt /usr/lib /usr/X11R6/lib/X11/qt /usr/X11R6/lib/qt /usr/lib/qt/lib"
 
+if test -n "$QTDIR" ; then
+    qt4_incdirs="$QTDIR/include $qt4_incdirs"
+    qt4_libdirs="$QTDIR/lib $qt4_libdirs"
+fi
+
 dnl What to test
 qt4test_test_include="QtTest/QtTest"
 qt4test_test_la_library="libQtTest.la"
diff -Nur poppler.0_5_0/poppler/Annot.cc poppler.HEAD/poppler/Annot.cc
--- poppler.0_5_0/poppler/Annot.cc	2005-10-16 16:54:17.000000000 +0200
+++ poppler.HEAD/poppler/Annot.cc	2006-02-06 19:50:11.000000000 +0100
@@ -18,6 +18,7 @@
 #include "Catalog.h"
 #include "Gfx.h"
 #include "Lexer.h"
+#include "UGooString.h"
 #include "Annot.h"
 
 //------------------------------------------------------------------------
@@ -210,15 +211,14 @@
 
     // build the appearance stream dictionary
     appearDict.initDict(xref);
-    appearDict.dictAdd(copyString("Length"),
-		       obj1.initInt(appearBuf->getLength()));
-    appearDict.dictAdd(copyString("Subtype"), obj1.initName("Form"));
+    appearDict.dictAdd("Length", obj1.initInt(appearBuf->getLength()));
+    appearDict.dictAdd("Subtype", obj1.initName("Form"));
     obj1.initArray(xref);
     obj1.arrayAdd(obj2.initReal(0));
     obj1.arrayAdd(obj2.initReal(0));
     obj1.arrayAdd(obj2.initReal(xMax - xMin));
     obj1.arrayAdd(obj2.initReal(yMax - yMin));
-    appearDict.dictAdd(copyString("BBox"), &obj1);
+    appearDict.dictAdd("BBox", &obj1);
 
     // find the resource dictionary
     dict->lookup("DR", &drObj);
@@ -243,7 +243,7 @@
       }
     }
     if (drObj.isDict()) {
-      appearDict.dictAdd(copyString("Resources"), drObj.copy(&obj1));
+      appearDict.dictAdd("Resources", drObj.copy(&obj1));
     }
     drObj.free();
 
diff -Nur poppler.0_5_0/poppler/ArthurOutputDev.cc poppler.HEAD/poppler/ArthurOutputDev.cc
--- poppler.0_5_0/poppler/ArthurOutputDev.cc	2005-10-30 21:29:05.000000000 +0100
+++ poppler.HEAD/poppler/ArthurOutputDev.cc	2006-02-14 00:04:54.000000000 +0100
@@ -245,11 +245,13 @@
   GfxFontType fontType;
   SplashOutFontFileID *id;
   SplashFontFile *fontFile;
+  SplashFontSrc *fontsrc;
   FoFiTrueType *ff;
   Ref embRef;
   Object refObj, strObj;
-  GooString *tmpFileName, *fileName, *substName;
-  FILE *tmpFile;
+  GooString *fileName, *substName;
+  char *tmpBuf;
+  int tmpBufLen;
   Gushort *codeToGID;
   DisplayFontParam *dfp;
   double m11, m12, m21, m22, w1, w2;
@@ -259,7 +261,8 @@
 
   m_needFontUpdate = false;
   m_font = NULL;
-  tmpFileName = NULL;
+  fileName = NULL;
+  tmpBuf = NULL;
   substIdx = -1;
 
   if (!(gfxFont = state->getFont())) {
@@ -279,22 +282,9 @@
 
     // if there is an embedded font, write it to disk
     if (gfxFont->getEmbeddedFontID(&embRef)) {
-      if (!openTempFile(&tmpFileName, &tmpFile, "wb", NULL)) {
-	error(-1, "Couldn't create temporary font file");
+      tmpBuf = gfxFont->readEmbFontFile(xref, &tmpBufLen);
+      if (! tmpBuf)
 	goto err2;
-      }
-      refObj.initRef(embRef.num, embRef.gen);
-      refObj.fetch(xref, &strObj);
-      refObj.free();
-      strObj.streamReset();
-      while ((c = strObj.streamGetChar()) != EOF) {
-	fputc(c, tmpFile);
-      }
-      strObj.streamClose();
-      strObj.free();
-      fclose(tmpFile);
-      fileName = tmpFileName;
-
     // if there is an external font file, use it
     } else if (!(fileName = gfxFont->getExtFontFile())) {
 
@@ -321,13 +311,18 @@
       }
     }
 
+    fontsrc = new SplashFontSrc;
+    if (fileName)
+      fontsrc->setFile(fileName, gFalse);
+    else
+      fontsrc->setBuf(tmpBuf, tmpBufLen, gFalse);
+
     // load the font file
     switch (fontType) {
     case fontType1:
       if (!(fontFile = m_fontEngine->loadType1Font(
 			   id,
-			   fileName->getCString(),
-			   fileName == tmpFileName,
+			   fontsrc,
 			   ((Gfx8BitFont *)gfxFont)->getEncoding()))) {
 	error(-1, "Couldn't create a font for '%s'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
@@ -338,8 +333,7 @@
     case fontType1C:
       if (!(fontFile = m_fontEngine->loadType1CFont(
 			   id,
-			   fileName->getCString(),
-			   fileName == tmpFileName,
+			   fontsrc,
 			   ((Gfx8BitFont *)gfxFont)->getEncoding()))) {
 	error(-1, "Couldn't create a font for '%s'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
@@ -355,8 +349,7 @@
       delete ff;
       if (!(fontFile = m_fontEngine->loadTrueTypeFont(
 			   id,
-			   fileName->getCString(),
-			   fileName == tmpFileName,
+			   fontsrc,
 			   codeToGID, 256))) {
 	error(-1, "Couldn't create a font for '%s'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
@@ -368,8 +361,7 @@
     case fontCIDType0C:
       if (!(fontFile = m_fontEngine->loadCIDFont(
 			   id,
-			   fileName->getCString(),
-			   fileName == tmpFileName))) {
+			   fontsrc))) {
 	error(-1, "Couldn't create a font for '%s'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
 	                         : "(unnamed)");
@@ -383,8 +375,7 @@
 	     n * sizeof(Gushort));
       if (!(fontFile = m_fontEngine->loadTrueTypeFont(
 			   id,
-			   fileName->getCString(),
-			   fileName == tmpFileName,
+			   fontsrc,
 			   codeToGID, n))) {
 	error(-1, "Couldn't create a font for '%s'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
@@ -408,17 +399,11 @@
   mat[2] = m21;  mat[3] = -m22;
   m_font = m_fontEngine->getFont(fontFile, mat);
 
-  if (tmpFileName) {
-    delete tmpFileName;
-  }
   return;
 
  err2:
   delete id;
  err1:
-  if (tmpFileName) {
-    delete tmpFileName;
-  }
   return;
 }
 
diff -Nur poppler.0_5_0/poppler/CairoOutputDev.cc poppler.HEAD/poppler/CairoOutputDev.cc
--- poppler.0_5_0/poppler/CairoOutputDev.cc	2006-01-10 18:55:59.000000000 +0100
+++ poppler.HEAD/poppler/CairoOutputDev.cc	2006-02-18 21:17:00.000000000 +0100
@@ -194,7 +194,11 @@
 
 void CairoOutputDev::updateLineWidth(GfxState *state) {
   LOG(printf ("line width: %f\n", state->getTransformedLineWidth()));
-  cairo_set_line_width (cairo, state->getTransformedLineWidth());
+  if (state->getTransformedLineWidth() == 0.0) {
+      cairo_set_line_width (cairo, 72.0/300.0);
+  } else {
+      cairo_set_line_width (cairo, state->getTransformedLineWidth());
+  }
 }
 
 void CairoOutputDev::updateFillColor(GfxState *state) {
@@ -477,6 +481,26 @@
   int invert_bit;
   int row_stride;
 
+  ctm = state->getCTM();
+  LOG (printf ("drawImageMask %dx%d, matrix: %f, %f, %f, %f, %f, %f\n",
+	       width, height, ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]));
+  matrix.xx = ctm[0] / width;
+  matrix.xy = -ctm[2] / height;
+  matrix.yx = ctm[1] / width;
+  matrix.yy = -ctm[3] / height;
+  matrix.x0 = ctm[2] + ctm[4];
+  matrix.y0 = ctm[3] + ctm[5];
+
+  /* work around a cairo bug when scaling 1x1 surfaces */
+  if (width == 1 && height == 1) {
+    cairo_save (cairo);
+    cairo_set_matrix (cairo, &matrix);
+    cairo_rectangle (cairo, 0., 0., 1., 1.);
+    cairo_fill (cairo);
+    cairo_restore (cairo);
+    return;
+  }
+
   row_stride = (width + 3) & ~3;
   buffer = (unsigned char *) malloc (height * row_stride);
   if (buffer == NULL) {
@@ -510,6 +534,98 @@
   if (pattern == NULL)
     return;
 
+  cairo_matrix_invert (&matrix);
+  cairo_pattern_set_matrix (pattern, &matrix);
+
+  /* we should actually be using CAIRO_FILTER_NEAREST here. However,
+   * cairo doesn't yet do minifaction filtering causing scaled down
+   * images with CAIRO_FILTER_NEAREST to look really bad */
+  cairo_pattern_set_filter (pattern, CAIRO_FILTER_BEST);
+
+  /* FIXME: Doesn't the image mask support any colorspace? */
+  cairo_set_source (cairo, fill_pattern);
+  cairo_mask (cairo, pattern);
+
+  cairo_pattern_destroy (pattern);
+  cairo_surface_destroy (image);
+  free (buffer);
+  delete imgStr;
+}
+
+void CairoOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str,
+				int width, int height,
+				GfxImageColorMap *colorMap,
+				Stream *maskStr,
+				int maskWidth, int maskHeight,
+				GfxImageColorMap *maskColorMap)
+{
+  ImageStream *maskImgStr;
+  maskImgStr = new ImageStream(maskStr, maskWidth,
+				       maskColorMap->getNumPixelComps(),
+				       maskColorMap->getBits());
+  maskImgStr->reset();
+
+  int row_stride = (maskWidth + 3) & ~3;
+  unsigned char *maskBuffer;
+  maskBuffer = (unsigned char *)gmalloc (row_stride * maskHeight);
+  unsigned char *maskDest;
+  cairo_surface_t *maskImage;
+  cairo_pattern_t *maskPattern;
+  Guchar *pix;
+  int x, y;
+  for (y = 0; y < maskHeight; y++) {
+    maskDest = (unsigned char *) (maskBuffer + y * row_stride);
+    pix = maskImgStr->getLine();
+    maskColorMap->getGrayLine (pix, maskDest, maskWidth);
+  }
+
+  maskImage = cairo_image_surface_create_for_data (maskBuffer, CAIRO_FORMAT_A8,
+						 maskWidth, maskHeight, row_stride);
+
+  delete maskImgStr;
+  maskStr->close();
+
+  unsigned char *buffer;
+  unsigned int *dest;
+  cairo_surface_t *image;
+  cairo_pattern_t *pattern;
+  ImageStream *imgStr;
+  GfxRGB rgb;
+  int alpha, i;
+  double *ctm;
+  cairo_matrix_t matrix;
+  int is_identity_transform;
+
+  buffer = (unsigned char *)gmalloc (width * height * 4);
+
+  /* TODO: Do we want to cache these? */
+  imgStr = new ImageStream(str, width,
+			   colorMap->getNumPixelComps(),
+			   colorMap->getBits());
+  imgStr->reset();
+  
+  /* ICCBased color space doesn't do any color correction
+   * so check its underlying color space as well */
+  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||
+		  colorMap->getColorSpace()->getMode() == csICCBased && 
+		  ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB;
+
+  for (y = 0; y < height; y++) {
+    dest = (unsigned int *) (buffer + y * 4 * width);
+    pix = imgStr->getLine();
+    colorMap->getRGBLine (pix, dest, width);
+  }
+
+  image = cairo_image_surface_create_for_data (buffer, CAIRO_FORMAT_RGB24,
+						 width, height, width * 4);
+
+  if (image == NULL)
+    return;
+  pattern = cairo_pattern_create_for_surface (image);
+  maskPattern = cairo_pattern_create_for_surface (maskImage);
+  if (pattern == NULL)
+    return;
+
   ctm = state->getCTM();
   LOG (printf ("drawImageMask %dx%d, matrix: %f, %f, %f, %f, %f, %f\n",
 	       width, height, ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]));
@@ -519,20 +635,24 @@
   matrix.yy = -ctm[3] / height;
   matrix.x0 = ctm[2] + ctm[4];
   matrix.y0 = ctm[3] + ctm[5];
+
   cairo_matrix_invert (&matrix);
+
   cairo_pattern_set_matrix (pattern, &matrix);
+  cairo_pattern_set_matrix (maskPattern, &matrix);
 
-  cairo_pattern_set_filter (pattern, CAIRO_FILTER_BEST);
-  /* FIXME: Doesn't the image mask support any colorspace? */
-  cairo_set_source (cairo, fill_pattern);
-  cairo_mask (cairo, pattern);
+  cairo_pattern_set_filter (pattern, CAIRO_FILTER_BILINEAR);
+  cairo_set_source (cairo, pattern);
+  cairo_mask (cairo, maskPattern);
 
+  cairo_pattern_destroy (maskPattern);
+  cairo_surface_destroy (maskImage);
   cairo_pattern_destroy (pattern);
   cairo_surface_destroy (image);
   free (buffer);
+  free (maskBuffer);
   delete imgStr;
 }
-
 void CairoOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,
 				int width, int height,
 				GfxImageColorMap *colorMap,
diff -Nur poppler.0_5_0/poppler/CairoOutputDev.h poppler.HEAD/poppler/CairoOutputDev.h
--- poppler.0_5_0/poppler/CairoOutputDev.h	2006-01-10 18:55:59.000000000 +0100
+++ poppler.HEAD/poppler/CairoOutputDev.h	2006-02-18 21:17:00.000000000 +0100
@@ -117,6 +117,12 @@
   virtual void drawImage(GfxState *state, Object *ref, Stream *str,
 			 int width, int height, GfxImageColorMap *colorMap,
 			 int *maskColors, GBool inlineImg);
+  virtual void drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str,
+				int width, int height,
+				GfxImageColorMap *colorMap,
+				Stream *maskStr,
+				int maskWidth, int maskHeight,
+				GfxImageColorMap *maskColorMap);
 
   //----- Type 3 font operators
   virtual void type3D0(GfxState *state, double wx, double wy);
diff -Nur poppler.0_5_0/poppler/Catalog.cc poppler.HEAD/poppler/Catalog.cc
--- poppler.0_5_0/poppler/Catalog.cc	2005-09-15 14:52:36.000000000 +0200
+++ poppler.HEAD/poppler/Catalog.cc	2006-01-18 23:32:13.000000000 +0100
@@ -23,6 +23,7 @@
 #include "Error.h"
 #include "Link.h"
 #include "PageLabelInfo.h"
+#include "UGooString.h"
 #include "Catalog.h"
 
 //------------------------------------------------------------------------
@@ -83,11 +84,14 @@
   // read named destination dictionary
   catDict.dictLookup("Dests", &dests);
 
-  // read root of named destination tree
+  // read root of named destination tree - PDF1.6 table 3.28
   if (catDict.dictLookup("Names", &obj)->isDict()) {
     obj.dictLookup("Dests", &obj2);
     destNameTree.init(xref, &obj2);
     obj2.free();
+    obj.dictLookup("EmbeddedFiles", &obj2);
+    embeddedFileNameTree.init(xref, &obj2);
+    obj2.free();
   }
   obj.free();
 
@@ -178,6 +182,7 @@
   }
   dests.free();
   destNameTree.free();
+  embeddedFileNameTree.free();
   if (baseURI) {
     delete baseURI;
   }
@@ -291,7 +296,7 @@
   return 0;
 }
 
-LinkDest *Catalog::findDest(GooString *name) {
+LinkDest *Catalog::findDest(UGooString *name) {
   LinkDest *dest;
   Object obj1, obj2;
   GBool found;
@@ -299,7 +304,7 @@
   // try named destination dictionary then name tree
   found = gFalse;
   if (dests.isDict()) {
-    if (!dests.dictLookup(name->getCString(), &obj1)->isNull())
+    if (!dests.dictLookup(*name, &obj1)->isNull())
       found = gTrue;
     else
       obj1.free();
@@ -335,6 +340,97 @@
   return dest;
 }
 
+EmbFile *Catalog::embeddedFile(int i)
+{
+    Object efDict;
+    Object fileSpec;
+    Object fileDesc;
+    Object paramDict;
+    Object paramObj;
+    Object strObj;
+    Object obj, obj2;
+    obj = embeddedFileNameTree.getValue(i);
+    GooString *fileName = new GooString();
+    char *descString = embeddedFileNameTree.getName(i)->getCString();
+    GooString *desc = new GooString(descString);
+    delete[] descString;
+    GooString *createDate = new GooString();
+    GooString *modDate = new GooString();
+    Stream *efStream;
+    if (obj.isRef()) {
+	if (obj.fetch(xref, &efDict)->isDict()) {
+	    // efDict matches Table 3.40 in the PDF1.6 spec
+	    efDict.dictLookup("F", &fileSpec);
+	    if (fileSpec.isString()) {
+		delete fileName;
+		fileName = new GooString(fileSpec.getString());
+	    }
+	    fileSpec.free();
+
+	    // the logic here is that the description from the name
+	    // dictionary is used if we don't have a more specific
+	    // description - see the Note: on page 157 of the PDF1.6 spec
+	    efDict.dictLookup("Desc", &fileDesc);
+	    if (fileDesc.isString()) {
+		delete desc;
+		desc = new GooString(fileDesc.getString());
+	    } else {
+		efDict.dictLookup("Description", &fileDesc);
+		if (fileDesc.isString()) {
+		    delete desc;
+		    desc = new GooString(fileDesc.getString());
+		}
+	    }
+	    fileDesc.free();
+	    
+	    efDict.dictLookup("EF", &obj2);
+	    if (obj2.isDict()) {
+		// This gives us the raw data stream bytes
+
+		obj2.dictLookup("F", &strObj);
+		if (strObj.isStream()) {
+		    efStream = strObj.getStream();
+		}
+
+		// dataDict corresponds to Table 3.41 in the PDF1.6 spec.
+		Dict *dataDict = efStream->getDict();
+
+		// subtype is normally mimetype. You can extract it with code like this:
+		// Object subtypeName;
+		// dataDict->lookup( "Subtype", &subtypeName );
+		// It is optional, so this will sometimes return a null object
+		// if (subtypeName.isName()) {
+		//        std::cout << "got subtype name: " << subtypeName.getName() << std::endl;
+		// }
+
+		// paramDict corresponds to Table 3.42 in the PDF1.6 spec
+		Object paramDict;
+		dataDict->lookup( "Params", &paramDict );
+		if (paramDict.isDict()) {
+		    paramDict.dictLookup("ModDate", &paramObj);
+		    if (paramObj.isString()) {
+			delete modDate;
+		        modDate = new GooString(paramObj.getString());
+		    }
+		    paramObj.free();
+		    paramDict.dictLookup("CreationDate", &paramObj);
+		    if (paramObj.isString()) {
+			delete createDate;
+		        createDate = new GooString(paramObj.getString());
+		    }
+		    paramObj.free();
+		}
+		paramDict.free();
+	    }
+	    efDict.free();
+	    obj2.free();
+	}
+    }
+    EmbFile *embeddedFile = new EmbFile(fileName, desc, createDate, modDate, strObj);
+    strObj.free();
+    return embeddedFile;
+}
+
 NameTree::NameTree(void)
 {
   size = 0;
@@ -343,12 +439,15 @@
 }
 
 NameTree::Entry::Entry(Array *array, int index) {
-  if (!array->getString(index, &name) || !array->getNF(index + 1, &value))
-    error(-1, "Invalid page tree");
+    GooString n;
+    if (!array->getString(index, &n) || !array->getNF(index + 1, &value))
+	error(-1, "Invalid page tree");
+    name = new UGooString(n);
 }
 
 NameTree::Entry::~Entry() {
   value.free();
+  delete name;
 }
 
 void NameTree::addEntry(Entry *entry)
@@ -402,13 +501,13 @@
 
 int NameTree::Entry::cmp(const void *voidKey, const void *voidEntry)
 {
-  GooString *key = (GooString *) voidKey;
+  UGooString *key = (UGooString *) voidKey;
   Entry *entry = *(NameTree::Entry **) voidEntry;
 
-  return key->cmp(&entry->name);
+  return key->cmp(entry->name);
 }
 
-GBool NameTree::lookup(GooString *name, Object *obj)
+GBool NameTree::lookup(UGooString *name, Object *obj)
 {
   Entry **entry;
 
@@ -424,6 +523,24 @@
   }
 }
 
+Object NameTree::getValue(int index)
+{
+  if (index < length) {
+    return entries[index]->value;
+  } else {
+    return Object();
+  }
+}
+
+UGooString *NameTree::getName(int index)
+{
+    if (index < length) {
+	return entries[index]->name;
+    } else {
+	return NULL;
+    }
+}
+
 void NameTree::free()
 {
   int i;
diff -Nur poppler.0_5_0/poppler/Catalog.h poppler.HEAD/poppler/Catalog.h
--- poppler.0_5_0/poppler/Catalog.h	2005-09-15 14:52:36.000000000 +0200
+++ poppler.HEAD/poppler/Catalog.h	2006-01-18 23:32:13.000000000 +0100
@@ -19,6 +19,7 @@
 class PageAttrs;
 struct Ref;
 class LinkDest;
+class UGooString;
 class PageLabelInfo;
 
 //------------------------------------------------------------------------
@@ -30,14 +31,18 @@
   NameTree();
   void init(XRef *xref, Object *tree);
   void parse(Object *tree);
-  GBool lookup(GooString *name, Object *obj);
+  GBool lookup(UGooString *name, Object *obj);
   void free();
+  int numEntries() { return length; };
+  // iterator accessor
+  Object getValue(int i);
+  UGooString *getName(int i);
 
 private:
   struct Entry {
     Entry(Array *array, int index);
     ~Entry();
-    GooString name;
+    UGooString *name;
     Object value;
     void free();
     static int cmp(const void *key, const void *entry);
@@ -48,7 +53,45 @@
   XRef *xref;
   Object *root;
   Entry **entries;
-  int size, length;
+  int size, length; // size is the number of entries in
+                    // the array of Entry*
+                    // length is the number of real Entry
+};
+
+class EmbFile {
+public:
+  EmbFile(GooString *name, GooString *description, 
+	  GooString *createDate,
+	  GooString *modDate, Object objStr) :
+    m_name(name),
+    m_description(description),
+    m_createDate(createDate),
+    m_modDate(modDate)
+  {
+    objStr.copy(&m_objStr);
+  }
+
+  ~EmbFile()
+  {
+    delete m_name;
+    delete m_description;
+    delete m_modDate;
+    delete m_createDate;
+    m_objStr.free();
+  }
+
+  GooString *name() { return m_name; }
+  GooString *description() { return m_description; }
+  GooString *modDate() { return m_modDate; }
+  GooString *createDate() { return m_createDate; }
+  Object &streamObject() { return m_objStr; }
+
+private:
+  GooString *m_name;
+  GooString *m_description;
+  GooString *m_createDate;
+  GooString *m_modDate;
+  Object m_objStr;
 };
 
 //------------------------------------------------------------------------
@@ -92,7 +135,13 @@
 
   // Find a named destination.  Returns the link destination, or
   // NULL if <name> is not a destination.
-  LinkDest *findDest(GooString *name);
+  LinkDest *findDest(UGooString *name);
+
+  // Get the number of embedded files
+  int numEmbeddedFiles() { return embeddedFileNameTree.numEntries(); }
+
+  // Get the i'th file embedded (at the Document level) in the document
+  EmbFile *embeddedFile(int i);
 
   // Convert between page indices and page labels.
   GBool labelToIndex(GooString *label, int *index);
@@ -132,7 +181,8 @@
   int numPages;			// number of pages
   int pagesSize;		// size of pages array
   Object dests;			// named destination dictionary
-  NameTree destNameTree;	// name tree
+  NameTree destNameTree;	// named destination name-tree
+  NameTree embeddedFileNameTree;  // embedded file name-tree
   GooString *baseURI;		// base URI for URI-type links
   Object metadata;		// metadata stream
   Object structTreeRoot;	// structure tree root dictionary
diff -Nur poppler.0_5_0/poppler/CharCodeToUnicode.cc poppler.HEAD/poppler/CharCodeToUnicode.cc
--- poppler.0_5_0/poppler/CharCodeToUnicode.cc	2005-09-16 20:38:58.000000000 +0200
+++ poppler.HEAD/poppler/CharCodeToUnicode.cc	2006-01-18 19:54:12.000000000 +0100
@@ -243,8 +243,18 @@
 	}
 	if (!(n1 == 2 + nDigits && tok1[0] == '<' && tok1[n1 - 1] == '>' &&
 	      tok2[0] == '<' && tok2[n2 - 1] == '>')) {
-	  error(-1, "Illegal entry in bfchar block in ToUnicode CMap");
-	  continue;
+	  
+	  // check there was no line jump inside the token and so the length is 
+	  // longer than it should be
+	  int countAux = 0;
+	  for (int k = 0; k < n1; k++)
+	    if (tok1[k] != '\n' && tok1[k] != '\r') countAux++;
+	
+	  if (!(countAux == 2 + nDigits && tok1[0] == '<' && tok1[n1 - 1] == '>' &&
+	      tok2[0] == '<' && tok2[n2 - 1] == '>')) {
+	    error(-1, "Illegal entry in bfchar block in ToUnicode CMap");
+	    continue;
+	  }
 	}
 	tok1[n1 - 1] = tok2[n2 - 1] = '\0';
 	if (sscanf(tok1 + 1, "%x", &code1) != 1) {
@@ -268,8 +278,21 @@
 	}
 	if (!(n1 == 2 + nDigits && tok1[0] == '<' && tok1[n1 - 1] == '>' &&
 	      n2 == 2 + nDigits && tok2[0] == '<' && tok2[n2 - 1] == '>')) {
-	  error(-1, "Illegal entry in bfrange block in ToUnicode CMap");
-	  continue;
+	  // check there was no line jump inside the token and so the length is 
+	  // longer than it should be
+	  int countAux = 0;
+	  for (int k = 0; k < n1; k++)
+	    if (tok1[k] != '\n' && tok1[k] != '\r') countAux++;
+	  
+	  int countAux2 = 0;
+	  for (int k = 0; k < n1; k++)
+	    if (tok2[k] != '\n' && tok2[k] != '\r') countAux++;
+	  
+	  if (!(countAux == 2 + nDigits && tok1[0] == '<' && tok1[n1 - 1] == '>' &&
+	      countAux2 == 2 + nDigits && tok2[0] == '<' && tok2[n2 - 1] == '>')) {
+	    error(-1, "Illegal entry in bfrange block in ToUnicode CMap");
+	    continue;
+	  }
 	}
 	tok1[n1 - 1] = tok2[n2 - 1] = '\0';
 	if (sscanf(tok1 + 1, "%x", &code1) != 1 ||
diff -Nur poppler.0_5_0/poppler/Dict.cc poppler.HEAD/poppler/Dict.cc
--- poppler.0_5_0/poppler/Dict.cc	2005-08-27 10:43:43.000000000 +0200
+++ poppler.HEAD/poppler/Dict.cc	2006-01-18 23:32:13.000000000 +0100
@@ -16,6 +16,7 @@
 #include <string.h>
 #include "goo/gmem.h"
 #include "Object.h"
+#include "UGooString.h"
 #include "XRef.h"
 #include "Dict.h"
 
@@ -34,13 +35,13 @@
   int i;
 
   for (i = 0; i < length; ++i) {
-    gfree(entries[i].key);
+    delete entries[i].key;
     entries[i].val.free();
   }
   gfree(entries);
 }
 
-void Dict::add(char *key, Object *val) {
+void Dict::add(const UGooString &key, Object *val) {
   if (length == size) {
     if (length == 0) {
       size = 8;
@@ -49,16 +50,16 @@
     }
     entries = (DictEntry *)greallocn(entries, size, sizeof(DictEntry));
   }
-  entries[length].key = key;
+  entries[length].key = new UGooString(key);
   entries[length].val = *val;
   ++length;
 }
 
-inline DictEntry *Dict::find(char *key) {
+inline DictEntry *Dict::find(const UGooString &key) {
   int i;
 
   for (i = 0; i < length; ++i) {
-    if (!strcmp(key, entries[i].key))
+    if (!key.cmp(entries[i].key))
       return &entries[i];
   }
   return NULL;
@@ -70,13 +71,13 @@
   return (e = find("Type")) && e->val.isName(type);
 }
 
-Object *Dict::lookup(char *key, Object *obj) {
+Object *Dict::lookup(const UGooString &key, Object *obj) {
   DictEntry *e;
 
   return (e = find(key)) ? e->val.fetch(xref, obj) : obj->initNull();
 }
 
-Object *Dict::lookupNF(char *key, Object *obj) {
+Object *Dict::lookupNF(const UGooString &key, Object *obj) {
   DictEntry *e;
 
   return (e = find(key)) ? e->val.copy(obj) : obj->initNull();
@@ -102,7 +103,7 @@
   return success;
 }
 
-char *Dict::getKey(int i) {
+UGooString *Dict::getKey(int i) {
   return entries[i].key;
 }
 
diff -Nur poppler.0_5_0/poppler/Dict.h poppler.HEAD/poppler/Dict.h
--- poppler.0_5_0/poppler/Dict.h	2005-03-28 09:49:55.000000000 +0200
+++ poppler.HEAD/poppler/Dict.h	2006-01-18 23:32:13.000000000 +0100
@@ -15,12 +15,13 @@
 
 #include "Object.h"
 
+class UGooString;
 //------------------------------------------------------------------------
 // Dict
 //------------------------------------------------------------------------
 
 struct DictEntry {
-  char *key;
+  UGooString *key;
   Object val;
 };
 
@@ -40,20 +41,20 @@
   // Get number of entries.
   int getLength() { return length; }
 
-  // Add an entry.  NB: does not copy key.
-  void add(char *key, Object *val);
+  // Add an entry
+  void add(const UGooString &key, Object *val);
 
   // Check if dictionary is of specified type.
   GBool is(char *type);
 
   // Look up an entry and return the value.  Returns a null object
   // if <key> is not in the dictionary.
-  Object *lookup(char *key, Object *obj);
-  Object *lookupNF(char *key, Object *obj);
+  Object *lookup(const UGooString &key, Object *obj);
+  Object *lookupNF(const UGooString &key, Object *obj);
   GBool lookupInt(const char *key, const char *alt_key, int *value);
 
   // Iterative accessors.
-  char *getKey(int i);
+  UGooString *getKey(int i);
   Object *getVal(int i, Object *obj);
   Object *getValNF(int i, Object *obj);
 
@@ -70,7 +71,7 @@
   int length;			// number of entries in dictionary
   int ref;			// reference count
 
-  DictEntry *find(char *key);
+  DictEntry *find(const UGooString &key);
 };
 
 #endif
diff -Nur poppler.0_5_0/poppler/FontInfo.cc poppler.HEAD/poppler/FontInfo.cc
--- poppler.0_5_0/poppler/FontInfo.cc	2005-10-16 16:54:17.000000000 +0200
+++ poppler.HEAD/poppler/FontInfo.cc	2006-01-23 16:40:54.000000000 +0100
@@ -1,3 +1,4 @@
+#include "config.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
@@ -10,8 +11,8 @@
 #include "GfxFont.h"
 #include "Annot.h"
 #include "PDFDoc.h"
-#include "config.h"
 #include "FontInfo.h"
+#include "UGooString.h"
 
 FontInfoScanner::FontInfoScanner(PDFDoc *docA) {
   doc = docA;
diff -Nur poppler.0_5_0/poppler/Function.cc poppler.HEAD/poppler/Function.cc
--- poppler.0_5_0/poppler/Function.cc	2005-10-16 16:58:14.000000000 +0200
+++ poppler.HEAD/poppler/Function.cc	2006-01-18 23:32:13.000000000 +0100
@@ -22,6 +22,7 @@
 #include "Stream.h"
 #include "Error.h"
 #include "Function.h"
+#include "UGooString.h"
 
 //------------------------------------------------------------------------
 // Function
diff -Nur poppler.0_5_0/poppler/Gfx.cc poppler.HEAD/poppler/Gfx.cc
--- poppler.0_5_0/poppler/Gfx.cc	2005-12-08 19:17:42.000000000 +0100
+++ poppler.HEAD/poppler/Gfx.cc	2006-02-05 16:46:10.000000000 +0100
@@ -35,6 +35,7 @@
 #include "Error.h"
 #include "Gfx.h"
 #include "ProfileData.h"
+#include "UGooString.h"
 
 // the MSVC math.h doesn't define this
 #ifndef M_PI
@@ -3525,6 +3526,7 @@
 	break;
       }
       dict.dictAdd(key, &obj);
+      gfree(key);
     }
     parser->getObj(&obj);
   }
@@ -3590,9 +3592,16 @@
     printf("\n");
     fflush(stdout);
   }
+
+  if(numArgs == 2) {
+    out->beginMarkedContent(args[0].getName(),args[1].getDict());
+  } else {
+    out->beginMarkedContent(args[0].getName());
+  }
 }
 
 void Gfx::opEndMarkedContent(Object args[], int numArgs) {
+  out->endMarkedContent();
 }
 
 void Gfx::opMarkPoint(Object args[], int numArgs) {
@@ -3603,6 +3612,13 @@
     printf("\n");
     fflush(stdout);
   }
+
+  if(numArgs == 2) {
+    out->markPoint(args[0].getName(),args[1].getDict());
+  } else {
+    out->markPoint(args[0].getName());
+  }
+
 }
 
 //------------------------------------------------------------------------
diff -Nur poppler.0_5_0/poppler/GfxFont.cc poppler.HEAD/poppler/GfxFont.cc
--- poppler.0_5_0/poppler/GfxFont.cc	2005-10-16 17:11:32.000000000 +0200
+++ poppler.HEAD/poppler/GfxFont.cc	2006-02-05 16:46:10.000000000 +0100
@@ -28,6 +28,7 @@
 #include <fofi/FoFiType1.h>
 #include <fofi/FoFiType1C.h>
 #include <fofi/FoFiTrueType.h>
+#include "UGooString.h"
 #include "GfxFont.h"
 
 //------------------------------------------------------------------------
@@ -360,7 +361,7 @@
 
 void GfxFont::findExtFontFile() {
   static char *type1Exts[] = { ".pfa", ".pfb", ".ps", "", NULL };
-  static char *ttExts[] = { ".ttf", NULL };
+  static char *ttExts[] = { ".ttf", ".ttc", NULL };
 
   if (name) {
     if (type == fontType1) {
@@ -1521,6 +1522,54 @@
   return cMap ? cMap->getCollection() : (GooString *)NULL;
 }
 
+Gushort *GfxCIDFont::getCodeToGIDMap(FoFiTrueType *ff, int *mapsizep) {
+  Gushort *map;
+  int cmapPlatform, cmapEncoding;
+  int unicodeCmap, macRomanCmap, msSymbolCmap, cmap;
+  GBool useMacRoman, useUnicode;
+  char *charName;
+  Unicode u;
+  int code, i;
+  int mapsize;
+  int cidlen;
+
+  *mapsizep = 0;
+  if (!ctu) return NULL;
+
+  /* we use only unicode cmap */
+  cmap = -1;
+  for (i = 0; i < ff->getNumCmaps(); ++i) {
+    cmapPlatform = ff->getCmapPlatform(i);
+    cmapEncoding = ff->getCmapEncoding(i);
+    if ((cmapPlatform == 3 && cmapEncoding == 1) || cmapPlatform == 0)
+      cmap = i;
+  }
+  if (cmap < 0)
+    return NULL;
+
+  cidlen = 0;
+  mapsize = 64;
+  map = (Gushort *)gmalloc(mapsize * sizeof(Gushort));
+
+  while (cidlen < ctu->getLength()) {
+    int n;
+    if ((n = ctu->mapToUnicode((CharCode)cidlen, &u, 1)) == 0) {
+      cidlen++;
+      continue;
+    }
+    if (cidlen >= mapsize) {
+      while (cidlen >= mapsize)
+	mapsize *= 2;
+      map = (Gushort *)grealloc(map, mapsize * sizeof(Gushort));
+    }
+    map[cidlen] = ff->mapCodeToGID(cmap, u);
+    cidlen++;
+  }
+
+  *mapsizep = cidlen;
+  return map;
+}
+
 //------------------------------------------------------------------------
 // GfxFontDict
 //------------------------------------------------------------------------
@@ -1549,8 +1598,10 @@
 	  r.gen = 999999;
 	}
       }
-      fonts[i] = GfxFont::makeFont(xref, fontDict->getKey(i),
+      char *aux = fontDict->getKey(i)->getCString();
+      fonts[i] = GfxFont::makeFont(xref, aux,
 				   r, obj2.getDict());
+      delete[] aux;
       if (fonts[i] && !fonts[i]->isOk()) {
 	delete fonts[i];
 	fonts[i] = NULL;
diff -Nur poppler.0_5_0/poppler/GfxFont.h poppler.HEAD/poppler/GfxFont.h
--- poppler.0_5_0/poppler/GfxFont.h	2005-07-06 19:12:36.000000000 +0200
+++ poppler.HEAD/poppler/GfxFont.h	2006-02-02 23:50:01.000000000 +0100
@@ -310,6 +310,8 @@
   Gushort *getCIDToGID() { return cidToGID; }
   int getCIDToGIDLen() { return cidToGIDLen; }
 
+  Gushort *getCodeToGIDMap(FoFiTrueType *ff, int *length);
+
 private:
 
   CMap *cMap;			// char code --> CID
diff -Nur poppler.0_5_0/poppler/GfxState.cc poppler.HEAD/poppler/GfxState.cc
--- poppler.0_5_0/poppler/GfxState.cc	2005-12-09 21:49:59.000000000 +0100
+++ poppler.HEAD/poppler/GfxState.cc	2006-02-18 21:17:00.000000000 +0100
@@ -21,6 +21,7 @@
 #include "Array.h"
 #include "Page.h"
 #include "GfxState.h"
+#include "UGooString.h"
 
 //------------------------------------------------------------------------
 
@@ -204,6 +205,23 @@
   }
 }
 
+void GfxColorSpace::getGrayLine(Guchar *in, unsigned char *out, int length) {
+  int i, j, n;
+  GfxColor color;
+  GfxGray gray;
+
+  n = getNComps();
+  for (i = 0; i < length; i++) {
+    
+    for (j = 0; j < n; j++)
+      color.c[j] = in[i * n + j] * 256;
+
+    getGray (&color, &gray);
+    out[i] = colToByte(gray);
+  }
+}
+
+
 //------------------------------------------------------------------------
 // GfxDeviceGrayColorSpace
 //------------------------------------------------------------------------
@@ -3433,6 +3451,39 @@
   }
 }
 
+void GfxImageColorMap::getGrayLine(Guchar *in, Guchar *out, int length) {
+  GfxColor color;
+  double *p;
+  int i, j;
+  Guchar *inp, *outp, *tmp_line;
+  GfxColorSpace *base;
+
+  switch (colorSpace->getMode()) {
+  case csIndexed:
+  case csSeparation:
+    tmp_line = (Guchar *) gmalloc (length * nComps2);
+    for (i = 0; i < length; i++) {
+      for (j = 0; j < nComps2; j++) {
+	tmp_line[i * nComps2 + j] = byte_lookup[in[i] * nComps2 + j];
+      }
+    }
+    colorSpace2->getGrayLine(tmp_line, out, length);
+    gfree (tmp_line);
+    break;
+
+  default:
+    inp = in;
+    for (j = 0; j < length; j++)
+      for (i = 0; i < nComps; i++) {
+	*inp = byte_lookup[*inp * nComps + i];
+	inp++;
+      }
+    colorSpace->getGrayLine(in, out, length);
+    break;
+  }
+
+}
+
 void GfxImageColorMap::getRGBLine(Guchar *in, unsigned int *out, int length) {
   GfxColor color;
   double *p;
diff -Nur poppler.0_5_0/poppler/GfxState.h poppler.HEAD/poppler/GfxState.h
--- poppler.0_5_0/poppler/GfxState.h	2005-10-30 21:29:05.000000000 +0100
+++ poppler.HEAD/poppler/GfxState.h	2006-02-18 21:17:00.000000000 +0100
@@ -151,6 +151,7 @@
   virtual void getRGB(GfxColor *color, GfxRGB *rgb) = 0;
   virtual void getCMYK(GfxColor *color, GfxCMYK *cmyk) = 0;
   virtual void getRGBLine(Guchar *in, unsigned int *out, int length);
+  virtual void getGrayLine(Guchar *in, Guchar *out, int length);
 
   // Return the number of color components.
   virtual int getNComps() = 0;
@@ -869,6 +870,7 @@
   void getGray(Guchar *x, GfxGray *gray);
   void getRGB(Guchar *x, GfxRGB *rgb);
   void getRGBLine(Guchar *in, unsigned int *out, int length);
+  void getGrayLine(Guchar *in, Guchar *out, int length);
   void getCMYK(Guchar *x, GfxCMYK *cmyk);
   void getColor(Guchar *x, GfxColor *color);
 
diff -Nur poppler.0_5_0/poppler/GlobalParams.cc poppler.HEAD/poppler/GlobalParams.cc
--- poppler.0_5_0/poppler/GlobalParams.cc	2005-12-08 19:17:42.000000000 +0100
+++ poppler.HEAD/poppler/GlobalParams.cc	2006-02-04 21:48:25.000000000 +0100
@@ -23,9 +23,6 @@
 #ifdef WIN32
 #  include <shlobj.h>
 #endif
-#if HAVE_PAPER_H
-#include <paper.h>
-#endif
 #include <fontconfig/fontconfig.h>
 #include "goo/gmem.h"
 #include "goo/GooString.h"
@@ -324,24 +321,8 @@
   cMapDirs = new GooHash(gTrue);
   toUnicodeDirs = new GooList();
   displayFonts = new GooHash();
-#if HAVE_PAPER_H
-  char *paperName;
-  const struct paper *paperType;
-  paperinit();
-  if ((paperName = systempapername())) {
-    paperType = paperinfo(paperName);
-    psPaperWidth = (int)paperpswidth(paperType);
-    psPaperHeight = (int)paperpsheight(paperType);
-  } else {
-    error(-1, "No paper information available - using defaults");
-    psPaperWidth = defPaperWidth;
-    psPaperHeight = defPaperHeight;
-  }
-  paperdone();
-#else
-  psPaperWidth = defPaperWidth;
-  psPaperHeight = defPaperHeight;
-#endif
+  psPaperWidth = -1;
+  psPaperHeight = -1;
   psImageableLLX = psImageableLLY = 0;
   psImageableURX = psPaperWidth;
   psImageableURY = psPaperHeight;
@@ -1122,7 +1103,7 @@
   }
 }
 
-FcPattern *buildFcPattern(GfxFont *font)
+static FcPattern *buildFcPattern(GfxFont *font)
 {
   int weight = FC_WEIGHT_NORMAL,
       slant = FC_SLANT_ROMAN,
@@ -1266,7 +1247,7 @@
 
 DisplayFontParam *GlobalParams::getDisplayFont(GfxFont *font) {
   DisplayFontParam *dfp;
-  FcPattern *p=0,*m=0;
+  FcPattern *p=0;
 
   GooString *fontName = font->getName();
   if (!fontName) return NULL;
@@ -1278,38 +1259,44 @@
     FcChar8* s;
     char * ext;
     FcResult res;
+    FcFontSet *set;
+    int i;
     p = buildFcPattern(font);
 
     if (!p)
       goto fin;
     FcConfigSubstitute(FCcfg, p, FcMatchPattern);
     FcDefaultSubstitute(p);
-    m = FcFontMatch(FCcfg,p,&res);
-    if (!m)
-      goto fin; 
-    res = FcPatternGetString(m, FC_FILE, 0, &s);
-    if (res != FcResultMatch || !s)
-      goto fin; 
-    ext = strrchr((char*)s,'.');
-    if (!ext)
+    set = FcFontSort(FCcfg, p, FcFalse, NULL, &res);
+    if (!set)
       goto fin;
-    if (!strncasecmp(ext,".ttf",4))
-    {
-      dfp = new DisplayFontParam(fontName->copy(), displayFontTT);  
-      dfp->tt.fileName = new GooString((char*)s);
-    }
-    else if (!strncasecmp(ext,".pfa",4) || !strncasecmp(ext,".pfb",4)) 
+    for (i = 0; i < set->nfont; ++i)
     {
-      dfp = new DisplayFontParam(fontName->copy(), displayFontT1);  
-      dfp->t1.fileName = new GooString((char*)s);
+      res = FcPatternGetString(set->fonts[i], FC_FILE, 0, &s);
+      if (res != FcResultMatch || !s)
+        continue;
+      ext = strrchr((char*)s,'.');
+      if (!ext)
+        continue;
+      if (!strncasecmp(ext,".ttf",4) || !strncasecmp(ext, ".ttc", 4))
+      {
+        dfp = new DisplayFontParam(fontName->copy(), displayFontTT);  
+        dfp->tt.fileName = new GooString((char*)s);
+        FcPatternGetInteger(set->fonts[i], FC_INDEX, 0, &(dfp->tt.faceIndex));
+      }
+      else if (!strncasecmp(ext,".pfa",4) || !strncasecmp(ext,".pfb",4)) 
+      {
+        dfp = new DisplayFontParam(fontName->copy(), displayFontT1);  
+        dfp->t1.fileName = new GooString((char*)s);
+      }
+      else
+        continue;
+      displayFonts->add(dfp->name,dfp);
+      break;
     }
-    else
-      goto fin;
-    displayFonts->add(dfp->name,dfp);
+    FcFontSetDestroy(set);
   }
 fin:
-  if (m)
-    FcPatternDestroy(m);
   if (p)
     FcPatternDestroy(p);
 
diff -Nur poppler.0_5_0/poppler/GlobalParams.h poppler.HEAD/poppler/GlobalParams.h
--- poppler.0_5_0/poppler/GlobalParams.h	2005-09-20 16:00:43.000000000 +0200
+++ poppler.HEAD/poppler/GlobalParams.h	2006-02-02 23:50:01.000000000 +0100
@@ -55,6 +55,7 @@
 
 struct DisplayFontParamTT {
   GooString *fileName;
+  int faceIndex;
 };
 
 class DisplayFontParam {
diff -Nur poppler.0_5_0/poppler/Lexer.cc poppler.HEAD/poppler/Lexer.cc
--- poppler.0_5_0/poppler/Lexer.cc	2005-08-31 17:28:46.000000000 +0200
+++ poppler.HEAD/poppler/Lexer.cc	2006-01-17 22:35:31.000000000 +0100
@@ -18,6 +18,7 @@
 #include <ctype.h>
 #include "Lexer.h"
 #include "Error.h"
+#include "XRef.h"
 
 //------------------------------------------------------------------------
 
@@ -46,9 +47,11 @@
 // Lexer
 //------------------------------------------------------------------------
 
-Lexer::Lexer(XRef *xref, Stream *str) {
+Lexer::Lexer(XRef *xrefA, Stream *str) {
   Object obj;
 
+  xref = xrefA;
+
   curStr.initStream(str);
   streams = new Array(xref);
   streams->add(curStr.copy(&obj));
@@ -57,9 +60,11 @@
   curStr.streamReset();
 }
 
-Lexer::Lexer(XRef *xref, Object *obj) {
+Lexer::Lexer(XRef *xrefA, Object *obj) {
   Object obj2;
 
+  xref = xrefA;
+
   if (obj->isStream()) {
     streams = new Array(xref);
     freeArray = gTrue;
@@ -108,7 +113,7 @@
   return curStr.streamLookChar();
 }
 
-Object *Lexer::getObj(Object *obj) {
+Object *Lexer::getObj(Object *obj, int objNum) {
   char *p;
   int c, c2;
   GBool comment, neg, done;
@@ -291,6 +296,17 @@
 	    s->append(tokBuf, tokBufSize);
 	  p = tokBuf;
 	  n = 0;
+	  
+	  // we are growing see if the document is not malformed and we are growing too much
+	  if (objNum != -1)
+	  {
+	    int newObjNum = xref->getNumEntry(getPos());
+	    if (newObjNum != objNum)
+	    {
+	      error(getPos(), "Unterminated string");
+	      done = gTrue;
+	    }
+	  }
 	}
 	*p++ = (char)c2;
 	++n;
diff -Nur poppler.0_5_0/poppler/Lexer.h poppler.HEAD/poppler/Lexer.h
--- poppler.0_5_0/poppler/Lexer.h	2005-08-31 17:28:46.000000000 +0200
+++ poppler.HEAD/poppler/Lexer.h	2006-01-17 22:35:31.000000000 +0100
@@ -29,17 +29,17 @@
 
   // Construct a lexer for a single stream.  Deletes the stream when
   // lexer is deleted.
-  Lexer(XRef *xref, Stream *str);
+  Lexer(XRef *xrefA, Stream *str);
 
   // Construct a lexer for a stream or array of streams (assumes obj
   // is either a stream or array of streams).
-  Lexer(XRef *xref, Object *obj);
+  Lexer(XRef *xrefA, Object *obj);
 
   // Destructor.
   ~Lexer();
 
   // Get the next object from the input stream.
-  Object *getObj(Object *obj);
+  Object *getObj(Object *obj, int objNum = -1);
 
   // Skip to the beginning of the next line in the input stream.
   void skipToNextLine();
@@ -73,6 +73,8 @@
   Object curStr;		// current stream
   GBool freeArray;		// should lexer free the streams array?
   char tokBuf[tokBufSize];	// temporary token buffer
+
+  XRef *xref;
 };
 
 #endif
diff -Nur poppler.0_5_0/poppler/Link.cc poppler.HEAD/poppler/Link.cc
--- poppler.0_5_0/poppler/Link.cc	2005-09-20 16:34:31.000000000 +0200
+++ poppler.HEAD/poppler/Link.cc	2006-01-18 23:32:13.000000000 +0100
@@ -21,6 +21,7 @@
 #include "Array.h"
 #include "Dict.h"
 #include "Link.h"
+#include "UGooString.h"
 
 //------------------------------------------------------------------------
 // LinkAction
@@ -421,9 +422,9 @@
 
   // named destination
   if (destObj->isName()) {
-    namedDest = new GooString(destObj->getName());
+    namedDest = new UGooString(destObj->getName());
   } else if (destObj->isString()) {
-    namedDest = destObj->getString()->copy();
+    namedDest = new UGooString(*destObj->getString());
 
   // destination dictionary
   } else if (destObj->isArray()) {
@@ -459,9 +460,9 @@
 
   // named destination
   if (destObj->isName()) {
-    namedDest = new GooString(destObj->getName());
+    namedDest = new UGooString(destObj->getName());
   } else if (destObj->isString()) {
-    namedDest = destObj->getString()->copy();
+    namedDest = new UGooString(*destObj->getString());
 
   // destination dictionary
   } else if (destObj->isArray()) {
diff -Nur poppler.0_5_0/poppler/Link.h poppler.HEAD/poppler/Link.h
--- poppler.0_5_0/poppler/Link.h	2005-03-03 20:46:01.000000000 +0100
+++ poppler.HEAD/poppler/Link.h	2006-01-18 23:32:13.000000000 +0100
@@ -16,6 +16,7 @@
 #include "Object.h"
 
 class GooString;
+class UGooString;
 class Array;
 class Dict;
 
@@ -134,13 +135,13 @@
   // Accessors.
   virtual LinkActionKind getKind() { return actionGoTo; }
   LinkDest *getDest() { return dest; }
-  GooString *getNamedDest() { return namedDest; }
+  UGooString *getNamedDest() { return namedDest; }
 
 private:
 
   LinkDest *dest;		// regular destination (NULL for remote
 				//   link with bad destination)
-  GooString *namedDest;		// named destination (only one of dest and
+  UGooString *namedDest;	// named destination (only one of dest and
 				//   and namedDest may be non-NULL)
 };
 
@@ -165,14 +166,14 @@
   virtual LinkActionKind getKind() { return actionGoToR; }
   GooString *getFileName() { return fileName; }
   LinkDest *getDest() { return dest; }
-  GooString *getNamedDest() { return namedDest; }
+  UGooString *getNamedDest() { return namedDest; }
 
 private:
 
   GooString *fileName;		// file name
   LinkDest *dest;		// regular destination (NULL for remote
 				//   link with bad destination)
-  GooString *namedDest;		// named destination (only one of dest and
+  UGooString *namedDest;	// named destination (only one of dest and
 				//   and namedDest may be non-NULL)
 };
 
diff -Nur poppler.0_5_0/poppler/Makefile.am poppler.HEAD/poppler/Makefile.am
--- poppler.0_5_0/poppler/Makefile.am	2006-01-06 11:05:58.000000000 +0100
+++ poppler.HEAD/poppler/Makefile.am	2006-02-16 20:28:54.000000000 +0100
@@ -92,6 +92,8 @@
 	$(zlib_libs)				\
 	$(FREETYPE_LIBS)
 
+libpoppler_la_LDFLAGS = -version-info 1:0:0
+
 if ENABLE_XPDF_HEADERS
 
 poppler_includedir = $(includedir)/poppler
@@ -146,6 +148,7 @@
 	PSOutputDev.h		\
 	TextOutputDev.h		\
 	SecurityHandler.h	\
+	UGooString.h		\
 	UTF8.h			\
 	XpdfPluginAPI.h		\
 	poppler-config.h
@@ -199,4 +202,5 @@
 	PageLabelInfo.h		\
 	PageLabelInfo.cc	\
 	SecurityHandler.cc	\
+	UGooString.cc	 	\
 	XpdfPluginAPI.cc
diff -Nur poppler.0_5_0/poppler/Object.h poppler.HEAD/poppler/Object.h
--- poppler.0_5_0/poppler/Object.h	2005-03-03 20:46:01.000000000 +0100
+++ poppler.HEAD/poppler/Object.h	2006-01-18 23:32:13.000000000 +0100
@@ -23,6 +23,7 @@
 class Array;
 class Dict;
 class Stream;
+class UGooString;
 
 //------------------------------------------------------------------------
 // Ref
@@ -163,11 +164,11 @@
 
   // Dict accessors.
   int dictGetLength();
-  void dictAdd(char *key, Object *val);
+  void dictAdd(const UGooString &key, Object *val);
   GBool dictIs(char *dictType);
-  Object *dictLookup(char *key, Object *obj);
-  Object *dictLookupNF(char *key, Object *obj);
-  char *dictGetKey(int i);
+  Object *dictLookup(const UGooString &key, Object *obj);
+  Object *dictLookupNF(const UGooString &key, Object *obj);
+  UGooString *dictGetKey(int i);
   Object *dictGetVal(int i, Object *obj);
   Object *dictGetValNF(int i, Object *obj);
 
@@ -238,7 +239,7 @@
 inline int Object::dictGetLength()
   { return dict->getLength(); }
 
-inline void Object::dictAdd(char *key, Object *val)
+inline void Object::dictAdd(const UGooString &key, Object *val)
   { dict->add(key, val); }
 
 inline GBool Object::dictIs(char *dictType)
@@ -247,13 +248,13 @@
 inline GBool Object::isDict(char *dictType)
   { return type == objDict && dictIs(dictType); }
 
-inline Object *Object::dictLookup(char *key, Object *obj)
+inline Object *Object::dictLookup(const UGooString &key, Object *obj)
   { return dict->lookup(key, obj); }
 
-inline Object *Object::dictLookupNF(char *key, Object *obj)
+inline Object *Object::dictLookupNF(const UGooString &key, Object *obj)
   { return dict->lookupNF(key, obj); }
 
-inline char *Object::dictGetKey(int i)
+inline UGooString *Object::dictGetKey(int i)
   { return dict->getKey(i); }
 
 inline Object *Object::dictGetVal(int i, Object *obj)
diff -Nur poppler.0_5_0/poppler/Outline.cc poppler.HEAD/poppler/Outline.cc
--- poppler.0_5_0/poppler/Outline.cc	2005-09-15 14:32:25.000000000 +0200
+++ poppler.HEAD/poppler/Outline.cc	2006-01-18 23:32:13.000000000 +0100
@@ -18,6 +18,7 @@
 #include "Link.h"
 #include "PDFDocEncoding.h"
 #include "Outline.h"
+#include "UGooString.h"
 
 //------------------------------------------------------------------------
 
diff -Nur poppler.0_5_0/poppler/OutputDev.cc poppler.HEAD/poppler/OutputDev.cc
--- poppler.0_5_0/poppler/OutputDev.cc	2005-10-30 21:29:05.000000000 +0100
+++ poppler.HEAD/poppler/OutputDev.cc	2006-02-04 22:10:41.000000000 +0100
@@ -121,6 +121,22 @@
   drawImage(state, ref, str, width, height, colorMap, NULL, gFalse);
 }
 
+void OutputDev::endMarkedContent() {
+}
+
+void OutputDev::beginMarkedContent(char *name) {
+}
+
+void OutputDev::beginMarkedContent(char *name, Dict *properties) {
+}
+
+void OutputDev::markPoint(char *name) {
+}
+
+void OutputDev::markPoint(char *name, Dict *properties) {
+}
+
+
 #if OPI_SUPPORT
 void OutputDev::opiBegin(GfxState *state, Dict *opiDict) {
 }
diff -Nur poppler.0_5_0/poppler/OutputDev.h poppler.HEAD/poppler/OutputDev.h
--- poppler.0_5_0/poppler/OutputDev.h	2005-11-01 16:29:32.000000000 +0100
+++ poppler.HEAD/poppler/OutputDev.h	2006-02-04 22:10:41.000000000 +0100
@@ -183,6 +183,16 @@
 				   int maskWidth, int maskHeight,
 				   GfxImageColorMap *maskColorMap);
 
+  //----- grouping operators
+
+  virtual void endMarkedContent();
+  virtual void beginMarkedContent(char *name);
+  virtual void beginMarkedContent(char *name, Dict *properties);
+  virtual void markPoint(char *name);
+  virtual void markPoint(char *name, Dict *properties);
+  
+  
+
 #if OPI_SUPPORT
   //----- OPI functions
   virtual void opiBegin(GfxState *state, Dict *opiDict);
diff -Nur poppler.0_5_0/poppler/Page.cc poppler.HEAD/poppler/Page.cc
--- poppler.0_5_0/poppler/Page.cc	2006-01-08 23:51:17.000000000 +0100
+++ poppler.HEAD/poppler/Page.cc	2006-01-18 23:32:13.000000000 +0100
@@ -29,6 +29,7 @@
 #endif
 #include "Error.h"
 #include "Page.h"
+#include "UGooString.h"
 
 //------------------------------------------------------------------------
 // PageAttrs
diff -Nur poppler.0_5_0/poppler/PageLabelInfo.cc poppler.HEAD/poppler/PageLabelInfo.cc
--- poppler.0_5_0/poppler/PageLabelInfo.cc	2005-07-29 00:56:17.000000000 +0200
+++ poppler.HEAD/poppler/PageLabelInfo.cc	2006-01-18 23:32:13.000000000 +0100
@@ -2,6 +2,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <assert.h>
+#include "UGooString.h"
 
 #include "PageLabelInfo.h"
 
diff -Nur poppler.0_5_0/poppler/Parser.cc poppler.HEAD/poppler/Parser.cc
--- poppler.0_5_0/poppler/Parser.cc	2005-09-20 17:27:31.000000000 +0200
+++ poppler.HEAD/poppler/Parser.cc	2006-01-18 23:32:13.000000000 +0100
@@ -20,6 +20,7 @@
 #include "XRef.h"
 #include "Error.h"
 #include "Decrypt.h"
+#include "UGooString.h"
 
 Parser::Parser(XRef *xrefA, Lexer *lexerA) {
   xref = xrefA;
@@ -68,7 +69,7 @@
 
   // dictionary or stream
   } else if (buf1.isCmd("<<")) {
-    shift();
+    shift(objNum);
     obj->initDict(xref);
     while (!buf1.isCmd(">>") && !buf1.isEOF()) {
       if (!buf1.isName()) {
@@ -82,6 +83,7 @@
 	  break;
 	}
 	obj->dictAdd(key, getObj(&obj2, fileKey, keyLength, objNum, objGen));
+	gfree(key);
       }
     }
     if (buf1.isEOF())
@@ -192,7 +194,7 @@
   return str;
 }
 
-void Parser::shift() {
+void Parser::shift(int objNum) {
   if (inlineImg > 0) {
     if (inlineImg < 2) {
       ++inlineImg;
@@ -210,5 +212,5 @@
   if (inlineImg > 0)		// don't buffer inline image data
     buf2.initNull();
   else
-    lexer->getObj(&buf2);
+    lexer->getObj(&buf2, objNum);
 }
diff -Nur poppler.0_5_0/poppler/Parser.h poppler.HEAD/poppler/Parser.h
--- poppler.0_5_0/poppler/Parser.h	2005-09-16 20:29:18.000000000 +0200
+++ poppler.HEAD/poppler/Parser.h	2006-01-17 22:35:31.000000000 +0100
@@ -47,7 +47,7 @@
   int inlineImg;		// set when inline image data is encountered
 
   Stream *makeStream(Object *dict);
-  void shift();
+  void shift(int objNum = -1);
 };
 
 #endif
diff -Nur poppler.0_5_0/poppler/PDFDoc.cc poppler.HEAD/poppler/PDFDoc.cc
--- poppler.0_5_0/poppler/PDFDoc.cc	2005-12-07 09:42:21.000000000 +0100
+++ poppler.HEAD/poppler/PDFDoc.cc	2006-01-18 23:32:13.000000000 +0100
@@ -38,6 +38,7 @@
 #include "Outline.h"
 #endif
 #include "PDFDoc.h"
+#include "UGooString.h"
 
 //------------------------------------------------------------------------
 
diff -Nur poppler.0_5_0/poppler/PDFDoc.h poppler.HEAD/poppler/PDFDoc.h
--- poppler.0_5_0/poppler/PDFDoc.h	2005-10-30 21:29:05.000000000 +0100
+++ poppler.HEAD/poppler/PDFDoc.h	2006-01-18 23:32:13.000000000 +0100
@@ -123,7 +123,7 @@
 
   // Find a named destination.  Returns the link destination, or
   // NULL if <name> is not a destination.
-  LinkDest *findDest(GooString *name)
+  LinkDest *findDest(UGooString *name)
     { return catalog->findDest(name); }
 
 #ifndef DISABLE_OUTLINE
diff -Nur poppler.0_5_0/poppler/poppler-config.h.in poppler.HEAD/poppler/poppler-config.h.in
--- poppler.0_5_0/poppler/poppler-config.h.in	2005-10-17 04:17:52.000000000 +0200
+++ poppler.HEAD/poppler/poppler-config.h.in	2006-01-23 19:52:48.000000000 +0100
@@ -14,11 +14,6 @@
 // around #undef look odd, but it's to silence warnings about
 // redefining those symbols.
 
-/* Use A4 paper size instead of Letter for PostScript output. */
-#ifndef A4_PAPER
-#undef A4_PAPER
-#endif
-
 /* Enable multithreading support. */
 #ifndef MULTITHREADING
 #undef MULTITHREADED
diff -Nur poppler.0_5_0/poppler/PSOutputDev.cc poppler.HEAD/poppler/PSOutputDev.cc
--- poppler.0_5_0/poppler/PSOutputDev.cc	2005-10-30 21:29:05.000000000 +0100
+++ poppler.HEAD/poppler/PSOutputDev.cc	2006-02-13 23:38:44.000000000 +0100
@@ -35,6 +35,7 @@
 #include "Stream.h"
 #include "Annot.h"
 #include "PSOutputDev.h"
+#include "UGooString.h"
 
 #ifdef MACOS
 // needed for setting type/creator of MacOS files
@@ -1039,6 +1040,7 @@
   fontFileNameSize = 64;
   fontFileNameLen = 0;
   fontFileNames = (GooString **)gmallocn(fontFileNameSize, sizeof(GooString *));
+  psFileNames = (GooString **)gmallocn(fontFileNameSize, sizeof(GooString *));
   nextTrueTypeNum = 0;
   font16EncLen = 0;
   font16EncSize = 0;
@@ -1123,6 +1125,13 @@
     }
     gfree(fontFileNames);
   }
+  if (psFileNames) {
+    for (i = 0; i < fontFileNameLen; ++i) {
+      if (psFileNames[i])
+        delete psFileNames[i];
+    }
+    gfree(psFileNames);
+  }
   if (font16Enc) {
     for (i = 0; i < font16EncLen; ++i) {
       delete font16Enc[i].enc;
@@ -1490,6 +1499,7 @@
   double w1, w2;
   double *fm;
   int i, j;
+  DisplayFontParam *dfp;
 
   // check if font is already set up
   for (i = 0; i < fontIDLen; ++i) {
@@ -1547,8 +1557,7 @@
   } else if (globalParams->getPSEmbedTrueType() &&
 	     font->getType() == fontTrueType &&
 	     font->getExtFontFile()) {
-    psName = filterPSName(font->getName());
-    setupExternalTrueTypeFont(font, psName);
+    psName = setupExternalTrueTypeFont(font);
 
   // check for embedded CID PostScript font
   } else if (globalParams->getPSEmbedCIDPostScript() &&
@@ -1570,6 +1579,12 @@
     psName = new GooString(type3Name);
     setupType3Font(font, psName, parentResDict);
 
+  // check for external CID TrueType font file
+  } else if (globalParams->getPSEmbedCIDTrueType() &&
+	     font->getType() == fontCIDType2 &&
+	     font->getExtFontFile()) {
+    psName = setupExternalCIDTrueTypeFont(font, font->getExtFontFile());
+
   // do 8-bit font substitution
   } else if (!font->isCIDFont()) {
     subst = gTrue;
@@ -1651,6 +1666,14 @@
 	    font16Enc[font16EncLen].enc->getCString());
     }
 
+  // try the display font for embedding
+  } else if (globalParams->getPSEmbedCIDTrueType() &&
+	     ((GfxCIDFont *)font)->getCollection() &&
+	     (dfp = globalParams->
+	      getDisplayFont(font)) &&
+	     dfp->kind == displayFontTT) {
+    psName = setupExternalCIDTrueTypeFont(font, dfp->tt.fileName, dfp->tt.faceIndex);
+
   // give up - can't do anything with this font
   } else {
     error(-1, "Couldn't find a font to substitute for '%s' ('%s' character collection)",
@@ -1860,8 +1883,12 @@
     fontFileNameSize += 64;
     fontFileNames = (GooString **)greallocn(fontFileNames,
 					  fontFileNameSize, sizeof(GooString *));
+    psFileNames = (GooString **)greallocn(psFileNames,
+				       fontFileNameSize, sizeof(GooString *));
   }
-  fontFileNames[fontFileNameLen++] = fileName->copy();
+  fontFileNames[fontFileNameLen] = fileName->copy();
+  psFileNames[fontFileNameLen] = psName->copy();
+  fontFileNameLen++;
 
   // beginning comment
   writePSFmt("%%%%BeginResource: font %s\n", psName->getCString());
@@ -1974,25 +2001,24 @@
   writePS("%%EndResource\n");
 }
 
-void PSOutputDev::setupExternalTrueTypeFont(GfxFont *font, GooString *psName) {
-  char unique[32];
+GooString *PSOutputDev::setupExternalTrueTypeFont(GfxFont *font) {
   GooString *fileName;
   char *fontBuf;
   int fontLen;
   FoFiTrueType *ffTT;
   Gushort *codeToGID;
+  GooString *psName;
   int i;
 
   // check if font is already embedded
   fileName = font->getExtFontFile();
   for (i = 0; i < fontFileNameLen; ++i) {
     if (!fontFileNames[i]->cmp(fileName)) {
-      sprintf(unique, "_%d", nextTrueTypeNum++);
-      psName->append(unique);
-      break;
+      return psFileNames[i]->copy();
     }
   }
 
+  psName = filterPSName(font->getName());
   // add entry to fontFileNames list
   if (i == fontFileNameLen) {
     if (fontFileNameLen >= fontFileNameSize) {
@@ -2000,9 +2026,14 @@
       fontFileNames =
 	(GooString **)greallocn(fontFileNames,
 			      fontFileNameSize, sizeof(GooString *));
+      psFileNames =
+	(GooString **)greallocn(psFileNames,
+			     fontFileNameSize, sizeof(GooString *));
     }
   }
-  fontFileNames[fontFileNameLen++] = fileName->copy();
+  fontFileNames[fontFileNameLen] = fileName->copy();
+  psFileNames[fontFileNameLen] = psName->copy();
+  fontFileNameLen++;
 
   // beginning comment
   writePSFmt("%%%%BeginResource: font %s\n", psName->getCString());
@@ -2025,6 +2056,82 @@
 
   // ending comment
   writePS("%%EndResource\n");
+  return psName;
+}
+
+GooString *PSOutputDev::setupExternalCIDTrueTypeFont(GfxFont *font, GooString *fileName, int faceIndex) {
+//   char *fontBuf;
+//   int fontLen;
+  FoFiTrueType *ffTT;
+  Gushort *codeToGID;
+  GooString *psName;
+  int i;
+  GooString *myFileName;
+
+  myFileName = fileName->copy();
+  if (faceIndex > 0) {
+    char tmp[32];
+    sprintf(tmp, ",%d", faceIndex);
+    myFileName->append(tmp);
+  }
+  // check if font is already embedded
+  for (i = 0; i < fontFileNameLen; ++i) {
+    if (!fontFileNames[i]->cmp(myFileName)) {
+      delete myFileName;
+      return psFileNames[i]->copy();
+    }
+  }
+
+  psName = filterPSName(font->getName());
+  // add entry to fontFileNames list
+  if (i == fontFileNameLen) {
+    if (fontFileNameLen >= fontFileNameSize) {
+      fontFileNameSize += 64;
+      fontFileNames =
+	(GooString **)grealloc(fontFileNames,
+			     fontFileNameSize * sizeof(GooString *));
+      psFileNames =
+	(GooString **)grealloc(psFileNames,
+			     fontFileNameSize * sizeof(GooString *));
+    }
+  }
+  fontFileNames[fontFileNameLen] = myFileName;
+  psFileNames[fontFileNameLen] = psName->copy();
+  fontFileNameLen++;
+
+  // beginning comment
+  writePSFmt("%%%%BeginResource: font %s\n", psName->getCString());
+  embFontList->append("%%+ font ");
+  embFontList->append(psName->getCString());
+  embFontList->append("\n");
+
+  // convert it to a CID type2 font
+  if ((ffTT = FoFiTrueType::load(fileName->getCString(), faceIndex))) {
+      int n = ((GfxCIDFont *)font)->getCIDToGIDLen();
+      if (n) {
+	codeToGID = (Gushort *)gmalloc(n * sizeof(Gushort));
+	memcpy(codeToGID, ((GfxCIDFont *)font)->getCIDToGID(), n * sizeof(Gushort));
+      } else {
+	codeToGID = ((GfxCIDFont *)font)->getCodeToGIDMap(ffTT, &n);
+      }
+      if (globalParams->getPSLevel() >= psLevel3) {
+	// Level 3: use a CID font
+	ffTT->convertToCIDType2(psName->getCString(),
+				codeToGID, n, gTrue,
+				outputFunc, outputStream);
+      } else {
+	// otherwise: use a non-CID composite font
+	ffTT->convertToType0(psName->getCString(),
+			     codeToGID, n, gTrue,
+			     outputFunc, outputStream);
+      }
+      gfree(codeToGID);
+      delete ffTT;
+  }
+
+  // ending comment
+  writePS("%%EndResource\n");
+  return psName;
 }
 
 void PSOutputDev::setupEmbeddedCIDType0Font(GfxFont *font, Ref *id,
@@ -2188,7 +2295,9 @@
     t3Cacheable = gFalse;
     for (i = 0; i < charProcs->getLength(); ++i) {
       writePS("/");
-      writePSName(charProcs->getKey(i));
+      char *aux = charProcs->getKey(i)->getCString();
+      writePSName(aux);
+      delete[] aux;
       writePS(" {\n");
       gfx->display(charProcs->getVal(i, &charProc));
       charProc.free();
diff -Nur poppler.0_5_0/poppler/PSOutputDev.h poppler.HEAD/poppler/PSOutputDev.h
--- poppler.0_5_0/poppler/PSOutputDev.h	2005-10-30 21:29:05.000000000 +0100
+++ poppler.HEAD/poppler/PSOutputDev.h	2006-02-13 23:38:44.000000000 +0100
@@ -237,10 +237,11 @@
   void setupExternalType1Font(GooString *fileName, GooString *psName);
   void setupEmbeddedType1CFont(GfxFont *font, Ref *id, GooString *psName);
   void setupEmbeddedTrueTypeFont(GfxFont *font, Ref *id, GooString *psName);
-  void setupExternalTrueTypeFont(GfxFont *font, GooString *psName);
+  GooString *setupExternalTrueTypeFont(GfxFont *font);
   void setupEmbeddedCIDType0Font(GfxFont *font, Ref *id, GooString *psName);
   void setupEmbeddedCIDTrueTypeFont(GfxFont *font, Ref *id, GooString *psName,
 				    GBool needVerticalMetrics);
+  GooString *setupExternalCIDTrueTypeFont(GfxFont *font, GooString *fileName, int faceIndex = 0);
   void setupType3Font(GfxFont *font, GooString *psName, Dict *parentResDict);
   void setupImages(Dict *resDict);
   void setupImage(Ref id, Stream *str);
@@ -301,6 +302,7 @@
   int fontFileIDLen;		// number of entries in fontFileIDs array
   int fontFileIDSize;		// size of fontFileIDs array
   GooString **fontFileNames;	// list of names of all embedded external fonts
+  GooString **psFileNames;	// list of names of all embedded external fonts
   int fontFileNameLen;		// number of entries in fontFileNames array
   int fontFileNameSize;		// size of fontFileNames array
   int nextTrueTypeNum;		// next unique number to append to a TrueType
diff -Nur poppler.0_5_0/poppler/SecurityHandler.cc poppler.HEAD/poppler/SecurityHandler.cc
--- poppler.0_5_0/poppler/SecurityHandler.cc	2005-09-16 20:29:18.000000000 +0200
+++ poppler.HEAD/poppler/SecurityHandler.cc	2006-01-18 23:32:13.000000000 +0100
@@ -26,6 +26,7 @@
 #  include "XpdfPluginAPI.h"
 #endif
 #include "SecurityHandler.h"
+#include "UGooString.h"
 
 //------------------------------------------------------------------------
 // SecurityHandler
diff -Nur poppler.0_5_0/poppler/SplashOutputDev.cc poppler.HEAD/poppler/SplashOutputDev.cc
--- poppler.0_5_0/poppler/SplashOutputDev.cc	2005-10-30 21:29:05.000000000 +0100
+++ poppler.HEAD/poppler/SplashOutputDev.cc	2006-02-05 16:46:10.000000000 +0100
@@ -941,11 +941,13 @@
   GfxFontType fontType;
   SplashOutFontFileID *id;
   SplashFontFile *fontFile;
+  SplashFontSrc *fontsrc;
   FoFiTrueType *ff;
   Ref embRef;
   Object refObj, strObj;
-  GooString *tmpFileName, *fileName, *substName;
-  FILE *tmpFile;
+  GooString *fileName, *substName;
+  char *tmpBuf;
+  int tmpBufLen;
   Gushort *codeToGID;
   DisplayFontParam *dfp;
   CharCodeToUnicode *ctu;
@@ -954,10 +956,12 @@
   char *name;
   Unicode uBuf[8];
   int c, substIdx, n, code, cmap;
+  int faceIndex = 0;
 
   needFontUpdate = gFalse;
   font = NULL;
-  tmpFileName = NULL;
+  fileName = NULL;
+  tmpBuf = NULL;
   substIdx = -1;
   dfp = NULL;
 
@@ -978,22 +982,9 @@
 
     // if there is an embedded font, write it to disk
     if (gfxFont->getEmbeddedFontID(&embRef)) {
-      if (!openTempFile(&tmpFileName, &tmpFile, "wb", NULL)) {
-	error(-1, "Couldn't create temporary font file");
+      tmpBuf = gfxFont->readEmbFontFile(xref, &tmpBufLen);
+      if (! tmpBuf)
 	goto err2;
-      }
-      refObj.initRef(embRef.num, embRef.gen);
-      refObj.fetch(xref, &strObj);
-      refObj.free();
-      strObj.streamReset();
-      while ((c = strObj.streamGetChar()) != EOF) {
-	fputc(c, tmpFile);
-      }
-      strObj.streamClose();
-      strObj.free();
-      fclose(tmpFile);
-      fileName = tmpFileName;
-
     // if there is an external font file, use it
     } else if (!(fileName = gfxFont->getExtFontFile())) {
 
@@ -1016,18 +1007,23 @@
       case displayFontTT:
 	fileName = dfp->tt.fileName;
 	fontType = gfxFont->isCIDFont() ? fontCIDType2 : fontTrueType;
+	faceIndex = dfp->tt.faceIndex;
 	break;
       }
     }
 
+    fontsrc = new SplashFontSrc;
+    if (fileName)
+      fontsrc->setFile(fileName, gFalse);
+    else
+      fontsrc->setBuf(tmpBuf, tmpBufLen, gFalse);
+
     // load the font file
     switch (fontType) {
     case fontType1:
-      if (!(fontFile = fontEngine->loadType1Font(
-			   id,
-			   fileName->getCString(),
-			   fileName == tmpFileName,
-			   ((Gfx8BitFont *)gfxFont)->getEncoding()))) {
+      fontFile = fontEngine->loadType1Font(id, fontsrc, 
+					   ((Gfx8BitFont *)gfxFont)->getEncoding());
+      if (! fontFile) {
 	error(-1, "Couldn't create a font for '%s'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
 	                         : "(unnamed)");
@@ -1035,11 +1031,9 @@
       }
       break;
     case fontType1C:
-      if (!(fontFile = fontEngine->loadType1CFont(
-			   id,
-			   fileName->getCString(),
-			   fileName == tmpFileName,
-			   ((Gfx8BitFont *)gfxFont)->getEncoding()))) {
+      fontFile = fontEngine->loadType1CFont(id, fontsrc,
+					    ((Gfx8BitFont *)gfxFont)->getEncoding());
+      if (! fontFile) {
 	error(-1, "Couldn't create a font for '%s'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
 	                         : "(unnamed)");
@@ -1047,7 +1041,11 @@
       }
       break;
     case fontTrueType:
-      if ((ff = FoFiTrueType::load(fileName->getCString()))) {
+	if (fileName)
+	 ff = FoFiTrueType::load(fileName->getCString());
+	else
+	 ff = new FoFiTrueType(tmpBuf, tmpBufLen, gFalse);
+	if (ff) {
       codeToGID = ((Gfx8BitFont *)gfxFont)->getCodeToGIDMap(ff);
 	n = 256;
       delete ff;
@@ -1057,8 +1055,7 @@
       }
       if (!(fontFile = fontEngine->loadTrueTypeFont(
 			   id,
-			   fileName->getCString(),
-			   fileName == tmpFileName,
+			   fontsrc,
 			   codeToGID, n))) {
 	error(-1, "Couldn't create a font for '%s'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
@@ -1068,10 +1065,8 @@
       break;
     case fontCIDType0:
     case fontCIDType0C:
-      if (!(fontFile = fontEngine->loadCIDFont(
-			   id,
-			   fileName->getCString(),
-			   fileName == tmpFileName))) {
+      fontFile = fontEngine->loadCIDFont(id, fontsrc);
+      if (! fontFile) {
 	error(-1, "Couldn't create a font for '%s'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
 	                         : "(unnamed)");
@@ -1084,7 +1079,11 @@
       if (dfp) {
 	// create a CID-to-GID mapping, via Unicode
 	if ((ctu = ((GfxCIDFont *)gfxFont)->getToUnicode())) {
-	  if ((ff = FoFiTrueType::load(fileName->getCString()))) {
+		if (fileName)
+		 ff = FoFiTrueType::load(fileName->getCString());
+		else
+		 ff = new FoFiTrueType(tmpBuf, tmpBufLen, gFalse);
+		if (ff) {
 	    // look for a Unicode cmap
 	    for (cmap = 0; cmap < ff->getNumCmaps(); ++cmap) {
 	      if ((ff->getCmapPlatform(cmap) == 3 &&
@@ -1116,16 +1115,28 @@
       } else {
 	if (((GfxCIDFont *)gfxFont)->getCIDToGID()) {
       n = ((GfxCIDFont *)gfxFont)->getCIDToGIDLen();
-	  codeToGID = (Gushort *)gmallocn(n, sizeof(Gushort));
-      memcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(),
-	     n * sizeof(Gushort));
+	if (n) {
+		codeToGID = (Gushort *)gmallocn(n, sizeof(Gushort));
+		memcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(),
+			n * sizeof(Gushort));
+	} else {
+		if (fileName)
+		 ff = FoFiTrueType::load(fileName->getCString());
+		else
+		 ff = new FoFiTrueType(tmpBuf, tmpBufLen, gFalse);
+		if (! ff)
+		 goto err2;
+		codeToGID = ((GfxCIDFont *)gfxFont)->getCodeToGIDMap(ff, &n);
+		delete ff;
+	}
 	}
       }
       if (!(fontFile = fontEngine->loadTrueTypeFont(
 			   id,
-			   fileName->getCString(),
-			   fileName == tmpFileName,
-			   codeToGID, n))) {
+			   fontsrc,
+			   codeToGID,
+			   n,
+			   faceIndex))) {
 	error(-1, "Couldn't create a font for '%s'",
 	      gfxFont->getName() ? gfxFont->getName()->getCString()
 	                         : "(unnamed)");
@@ -1153,17 +1164,11 @@
   }
   font = fontEngine->getFont(fontFile, mat);
 
-  if (tmpFileName) {
-    delete tmpFileName;
-  }
   return;
 
  err2:
   delete id;
  err1:
-  if (tmpFileName) {
-    delete tmpFileName;
-  }
   return;
 }
 
diff -Nur poppler.0_5_0/poppler/Stream.cc poppler.HEAD/poppler/Stream.cc
--- poppler.0_5_0/poppler/Stream.cc	2006-01-11 17:52:58.000000000 +0100
+++ poppler.HEAD/poppler/Stream.cc	2006-01-18 23:32:13.000000000 +0100
@@ -33,6 +33,7 @@
 #include "JBIG2Stream.h"
 #include "JPXStream.h"
 #include "Stream-CCITT.h"
+#include "UGooString.h"
 
 #ifdef ENABLE_LIBJPEG
 #include "DCTStream.h"
diff -Nur poppler.0_5_0/poppler/UGooString.cc poppler.HEAD/poppler/UGooString.cc
--- poppler.0_5_0/poppler/UGooString.cc	1970-01-01 01:00:00.000000000 +0100
+++ poppler.HEAD/poppler/UGooString.cc	2006-01-18 23:36:01.000000000 +0100
@@ -0,0 +1,86 @@
+//========================================================================
+//
+// UGooString.cc
+//
+// Unicode string
+//
+// Copyright 2005 Albert Astals Cid <aacid@kde.org>
+//
+//========================================================================
+
+#include <string.h>
+
+#include "goo/gmem.h"
+#include "goo/GooString.h"
+#include "PDFDocEncoding.h"
+#include "UGooString.h"
+
+UGooString::UGooString(Unicode *u, int l)
+{
+  s = u;
+  length = l;
+}
+
+UGooString::UGooString(GooString &str)
+{
+  if ((str.getChar(0) & 0xff) == 0xfe && (str.getChar(1) & 0xff) == 0xff)
+  {
+    length = (str.getLength() - 2) / 2;
+    s = (Unicode *)gmallocn(length, sizeof(Unicode));
+    for (int j = 0; j < length; ++j) {
+      s[j] = ((str.getChar(2 + 2*j) & 0xff) << 8) | (str.getChar(3 + 2*j) & 0xff);
+    }
+  } else
+    initChar(str);
+}
+
+UGooString::UGooString(const UGooString &str)
+{
+  length = str.length;
+  s = (Unicode *)gmallocn(length, sizeof(Unicode));
+  memcpy(s, str.s, length * sizeof(Unicode));
+}
+
+UGooString::UGooString(const char *str)
+{
+  GooString aux(str);
+  initChar(aux);
+}
+
+void UGooString::initChar(GooString &str)
+{
+  length = str.getLength();
+  s = (Unicode *)gmallocn(length, sizeof(Unicode));
+  for (int j = 0; j < length; ++j) {
+    s[j] = pdfDocEncoding[str.getChar(j) & 0xff];
+  }
+}
+
+UGooString::~UGooString()
+{
+  gfree(s);
+}
+
+int UGooString::cmp(UGooString *str) const
+{
+  int n1, n2, i, x;
+  Unicode *p1, *p2;
+
+  n1 = length;
+  n2 = str->length;
+  for (i = 0, p1 = s, p2 = str->s; i < n1 && i < n2; ++i, ++p1, ++p2) {
+    x = *p1 - *p2;
+    if (x != 0) {
+      return x;
+    }
+  }
+  return n1 - n2;
+}
+
+char *UGooString::getCString() const
+{
+  char *res = new char[length + 1];
+  for (int i = 0; i < length; i++) res[i] = s[i];
+  res[length] = '\0';
+  return res;
+}
diff -Nur poppler.0_5_0/poppler/UGooString.h poppler.HEAD/poppler/UGooString.h
--- poppler.0_5_0/poppler/UGooString.h	1970-01-01 01:00:00.000000000 +0100
+++ poppler.HEAD/poppler/UGooString.h	2006-01-18 23:36:01.000000000 +0100
@@ -0,0 +1,55 @@
+//========================================================================
+//
+// UGooString.h
+//
+// Unicode string
+//
+// Copyright 2005 Albert Astals Cid <aacid@kde.org>
+//
+//========================================================================
+
+#ifndef UGooString_H
+#define UGooString_H
+
+#include "CharTypes.h"
+
+class GooString;
+
+class UGooString
+{
+public:
+  // Create an unicode string
+  UGooString(Unicode *u, int l);
+
+  // Create a unicode string from <str>.
+  UGooString(GooString &str);
+
+  // Copy the unicode string
+  UGooString(const UGooString &str);
+
+  // Create a unicode string from <str>.
+  UGooString(const char *str);
+
+  // Destructor.
+  ~UGooString();
+
+  // Get length.
+  int getLength() const { return length; }
+
+  // Compare two strings:  -1:<  0:=  +1:>
+  int cmp(UGooString *str) const;
+
+  // get the unicode
+  Unicode *unicode() const { return s; }
+
+  // get the const char*
+  char *getCString() const;
+
+private:
+  void initChar(GooString &str);
+
+  int length;
+  Unicode *s;
+};
+
+#endif
diff -Nur poppler.0_5_0/poppler/XRef.cc poppler.HEAD/poppler/XRef.cc
--- poppler.0_5_0/poppler/XRef.cc	2005-09-20 16:59:43.000000000 +0200
+++ poppler.HEAD/poppler/XRef.cc	2006-01-18 23:32:13.000000000 +0100
@@ -24,6 +24,7 @@
 #include "Dict.h"
 #include "Error.h"
 #include "ErrorCodes.h"
+#include "UGooString.h"
 #include "XRef.h"
 
 //------------------------------------------------------------------------
@@ -934,6 +935,23 @@
   return gTrue;
 }
 
+int XRef::getNumEntry(int offset) const
+{
+  int res = -1;
+  int resOffset = -1;
+  XRefEntry e;
+  for (int i = 0; i < size; ++i)
+  {
+    e = entries[i];
+    if (e.offset < offset && e.offset > resOffset)
+    {
+      res = i;
+      resOffset = e.offset;
+    }
+  }
+  return res;
+}
+
 Guint XRef::strToUnsigned(char *s) {
   Guint x;
   char *p;
diff -Nur poppler.0_5_0/poppler/XRef.h poppler.HEAD/poppler/XRef.h
--- poppler.0_5_0/poppler/XRef.h	2005-09-20 16:00:43.000000000 +0200
+++ poppler.HEAD/poppler/XRef.h	2006-01-17 22:35:31.000000000 +0100
@@ -94,6 +94,9 @@
   // Returns false if unknown or file is not damaged.
   GBool getStreamEnd(Guint streamStart, Guint *streamEnd);
 
+  // Retuns the entry that belongs to the offset
+  int getNumEntry(int offset) const;
+
   // Direct access.
   int getSize() { return size; }
   XRefEntry *getEntry(int i) { return &entries[i]; }
diff -Nur poppler.0_5_0/qt/Makefile.am poppler.HEAD/qt/Makefile.am
--- poppler.0_5_0/qt/Makefile.am	2006-01-06 11:05:59.000000000 +0100
+++ poppler.HEAD/qt/Makefile.am	2006-02-16 20:28:54.000000000 +0100
@@ -25,6 +25,8 @@
 	$(POPPLER_QT_LIBS)			\
 	$(FREETYPE_LIBS)
 
+libpoppler_qt_la_LDFLAGS = -version-info 1:0:0
+
 if BUILD_SPLASH_OUTPUT
 
 noinst_PROGRAMS = test-poppler-qt
diff -Nur poppler.0_5_0/qt/poppler-document.cc poppler.HEAD/qt/poppler-document.cc
--- poppler.0_5_0/qt/poppler-document.cc	2005-12-03 23:20:54.000000000 +0100
+++ poppler.HEAD/qt/poppler-document.cc	2006-01-18 23:32:13.000000000 +0100
@@ -24,6 +24,7 @@
 #include <Catalog.h>
 #include <ErrorCodes.h>
 #include <SplashOutputDev.h>
+#include <UGooString.h>
 #include <splash/SplashBitmap.h>
 #include "poppler-private.h"
 
diff -Nur poppler.0_5_0/qt/poppler-page.cc poppler.HEAD/qt/poppler-page.cc
--- poppler.0_5_0/qt/poppler-page.cc	2006-01-06 11:05:59.000000000 +0100
+++ poppler.HEAD/qt/poppler-page.cc	2006-01-10 22:57:28.000000000 +0100
@@ -28,6 +28,7 @@
 #include <TextOutputDev.h>
 #include <splash/SplashBitmap.h>
 #include "poppler-private.h"
+#include "poppler-page-transition-private.h"
 
 namespace Poppler {
 
diff -Nur poppler.0_5_0/qt/poppler-page-transition.cc poppler.HEAD/qt/poppler-page-transition.cc
--- poppler.0_5_0/qt/poppler-page-transition.cc	2006-01-06 11:05:59.000000000 +0100
+++ poppler.HEAD/qt/poppler-page-transition.cc	2006-01-18 23:32:13.000000000 +0100
@@ -18,8 +18,9 @@
 
 #include "Object.h"
 #include "Error.h"
+#include "UGooString.h"
 #include "poppler-page-transition.h"
-#include "poppler-private.h"
+#include "poppler-page-transition-private.h"
 
 namespace Poppler {
 
diff -Nur poppler.0_5_0/qt/poppler-page-transition.h poppler.HEAD/qt/poppler-page-transition.h
--- poppler.0_5_0/qt/poppler-page-transition.h	2006-01-06 11:05:59.000000000 +0100
+++ poppler.HEAD/qt/poppler-page-transition.h	2006-01-18 22:22:12.000000000 +0100
@@ -25,8 +25,25 @@
 class PageTransitionParams;
 class PageTransitionData;
 
+/**
+   \brief Describes how a PDF file viewer shall perform the transition
+   from one page to another
+
+   In PDF files there is a way to specify if the viewer shall use
+   certain effects to perform the transition from one page to
+   another. This feature can be used, e.g., in a PDF-based beamer
+   presentation.
+
+   This utility class represents the transition effect, and can be
+   used to extract the information from a PDF object.
+*/
+
+
 class PageTransition {
  public:
+
+  /** \brief transition effect that shall be used
+   */
   enum Type {
     Replace,
     Split,
@@ -42,11 +59,15 @@
     Fade
   };
   
+  /** \brief alignment of the transition effect that shall be used
+   */
   enum Alignment {
     Horizontal,
     Vertical
   };
   
+  /** \brief direction of the transition effect that shall be used
+   */
   enum Direction {
     Inward,
     Outward
@@ -54,17 +75,22 @@
   
   /** \brief Construct a new PageTransition object from a page dictionary.
 
-  In case or error, this method will print an error message to stderr,
+  Users of the library will rarely need to construct a
+  PageTransition object themselves. Instead, the method
+  Poppler::Page::transition() can be used to find out if a certain
+  transition effect is specified.
+
+  @warning In case or error, this method will print an error message to stderr,
   and construct a default object.
 
-  @param dictObj pointer to an object whose dictionary will be read
-  and parsed. The pointer dictObj must point to a valid object, whose
-  dictionaries are accessed by the constructor. The dictObj is only
-  accessed by this constructor, and may be deleted after the
-  constructor returns.
+  @param params an object whose dictionary will be read and
+   parsed. This must be a valid object, whose dictionaries are
+   accessed by the constructor. The object is only accessed by this
+   constructor, and may be deleted after the constructor returns.
   */
   PageTransition(const PageTransitionParams &params);
-  
+
+  /** \brief copy constructor */
   PageTransition(const PageTransition &pt);
   
   /**
diff -Nur poppler.0_5_0/qt/poppler-page-transition-private.h poppler.HEAD/qt/poppler-page-transition-private.h
--- poppler.0_5_0/qt/poppler-page-transition-private.h	1970-01-01 01:00:00.000000000 +0100
+++ poppler.HEAD/qt/poppler-page-transition-private.h	2006-01-17 21:33:08.000000000 +0100
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2005, Albert Astals Cid
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+class Object;
+
+namespace Poppler {
+
+class PageTransitionParams {
+  public:
+    Object *dictObj;
+};
+
+}
diff -Nur poppler.0_5_0/qt/poppler-private.h poppler.HEAD/qt/poppler-private.h
--- poppler.0_5_0/qt/poppler-private.h	2006-01-06 11:05:59.000000000 +0100
+++ poppler.HEAD/qt/poppler-private.h	2006-01-10 22:57:28.000000000 +0100
@@ -53,9 +53,4 @@
   SplashOutputDev *m_outputDev;
 };
 
-class PageTransitionParams {
-  public:
-    Object *dictObj;
-};
-
 }
diff -Nur poppler.0_5_0/qt4/src/Doxyfile poppler.HEAD/qt4/src/Doxyfile
--- poppler.0_5_0/qt4/src/Doxyfile	1970-01-01 01:00:00.000000000 +0100
+++ poppler.HEAD/qt4/src/Doxyfile	2006-01-18 22:22:12.000000000 +0100
@@ -0,0 +1,1212 @@
+# Doxyfile 1.4.1
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = 
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER         = 
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = 
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Brazilian, Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, 
+# Dutch, Finnish, French, German, Greek, Hungarian, Italian, Japanese, 
+# Japanese-en (Japanese with English messages), Korean, Korean-en, Norwegian, 
+# Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Slovene, Spanish, 
+# Swedish, and Ukrainian.
+
+OUTPUT_LANGUAGE        = English
+
+# This tag can be used to specify the encoding used in the generated output. 
+# The encoding is not always determined by the language that is chosen, 
+# but also whether or not the output is meant for Windows or non-Windows users. 
+# In case there is a difference, setting the USE_WINDOWS_ENCODING tag to YES 
+# forces the Windows encoding (this is the default for the Windows binary), 
+# whereas setting the tag to NO uses a Unix-style encoding (the default for 
+# all platforms other than Windows).
+
+USE_WINDOWS_ENCODING   = NO
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       = 
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
+# path to strip.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like the Qt-style comments (thus requiring an 
+# explicit @brief command for a brief description.
+
+JAVADOC_AUTOBRIEF      = YES
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the DETAILS_AT_TOP tag is set to YES then Doxygen 
+# will output the detailed description near the top, like JavaDoc.
+# If set to NO, the detailed description appears after the member 
+# documentation.
+
+DETAILS_AT_TOP         = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java sources 
+# only. Doxygen will then generate output that is more tailored for Java. 
+# For instance, namespaces will be presented as packages, qualified scopes 
+# will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the 
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
+# in the documentation.
+
+SHOW_DIRECTORIES       = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from the 
+# version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the progam writes to standard output 
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
+# documentation.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT                  = . ../../qt/poppler-page-transition.h
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm
+
+FILE_PATTERNS          = 
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE              = NO
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = 
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix filesystem feature) are excluded 
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories.
+
+EXCLUDE_PATTERNS       = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS       = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
+# ignored.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis.  Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match.  The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
+# is applied to all files.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES (the default) 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES (the default) 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = NO
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = APIDOCS-html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        = 
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compressed HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output directory.
+
+CHM_FILE               = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20]) 
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the GENERATE_TREEVIEW tag is set to YES, a side panel will be
+# generated containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+, 
+# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are 
+# probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW      = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX         = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = APIDOCS-latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = NO
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = NO
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD                = 
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_PREDEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
+# instead of the = operator.
+
+PREDEFINED             = UNSTABLE_POPPLER_QT4
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse 
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#   TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#   TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links.
+# Note that each tag file must have a unique name
+# (where the name does NOT include the path)
+# If a tag file is not located in the directory in which doxygen 
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option is superseded by the HAVE_DOT option below. This is only a 
+# fallback. It is recommended to install and use dot, since it yields more 
+# powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = NO
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
+# Language.
+
+UML_LOOK               = NO
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT tags are set to YES then doxygen will 
+# generate a call dependency graph for every global function or class method. 
+# Note that enabling this option will significantly increase the time of a run. 
+# So in most cases it will be better to enable call graphs for selected 
+# functions only using the \callgraph command.
+
+CALL_GRAPH             = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS           = 
+
+# The MAX_DOT_GRAPH_WIDTH tag can be used to set the maximum allowed width 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_WIDTH    = 1024
+
+# The MAX_DOT_GRAPH_HEIGHT tag can be used to set the maximum allows height 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_HEIGHT   = 1024
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
+# graphs generated by dot. A depth value of 3 means that only nodes reachable 
+# from the root by following a path via at most 3 edges will be shown. Nodes 
+# that lay further from the root node will be omitted. Note that setting this 
+# option to 1 or 2 may greatly reduce the computation time needed for large 
+# code bases. Also note that a graph may be further truncated if the graph's 
+# image dimensions are not sufficient to fit the graph (see MAX_DOT_GRAPH_WIDTH 
+# and MAX_DOT_GRAPH_HEIGHT). If 0 is used for the depth value (the default), 
+# the graph is not depth-constrained.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, which results in a white background. 
+# Warning: Depending on the platform used, enabling this option may lead to 
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to 
+# read).
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP            = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+
+# The SEARCHENGINE tag specifies whether or not a search engine should be 
+# used. If set to NO the values of all tags below this one will be ignored.
+
+SEARCHENGINE           = NO
diff -Nur poppler.0_5_0/qt4/src/Makefile.am poppler.HEAD/qt4/src/Makefile.am
--- poppler.0_5_0/qt4/src/Makefile.am	2006-01-06 11:05:59.000000000 +0100
+++ poppler.HEAD/qt4/src/Makefile.am	2006-02-16 20:28:54.000000000 +0100
@@ -1,6 +1,7 @@
 INCLUDES =					\
 	-I$(top_srcdir)				\
 	-I$(top_srcdir)/poppler			\
+	-I$(top_srcdir)/qt			\
 	$(POPPLER_QT4_CXXFLAGS)
 
 
@@ -16,6 +17,7 @@
 	poppler-document.cc			\
 	poppler-page.cc				\
 	poppler-fontinfo.cc			\
+	poppler-embeddedfile.cc			\
 	poppler-textbox.cc			\
 	../../qt/poppler-page-transition.cc	\
 	poppler-private.h
@@ -24,3 +26,5 @@
 	$(top_builddir)/poppler/libpoppler.la	\
 	$(POPPLER_QT4_LIBS)
 
+libpoppler_qt4_la_LDFLAGS = -version-info 1:0:0
+
diff -Nur poppler.0_5_0/qt4/src/poppler-document.cc poppler.HEAD/qt4/src/poppler-document.cc
--- poppler.0_5_0/qt4/src/poppler-document.cc	2006-01-01 23:35:48.000000000 +0100
+++ poppler.HEAD/qt4/src/poppler-document.cc	2006-01-18 23:32:13.000000000 +0100
@@ -25,10 +25,13 @@
 #include <GlobalParams.h>
 #include <PDFDoc.h>
 #include <Catalog.h>
+#include "UGooString.h"
 #include <ErrorCodes.h>
 #include <SplashOutputDev.h>
 #include <splash/SplashBitmap.h>
 #include "poppler-private.h"
+#include <Stream.h>
+#include <QtCore/QDebug>
 
 namespace Poppler {
 
@@ -50,6 +53,15 @@
 	    else
 		pdoc->m_doc->locked = false;
 	    pdoc->m_doc->m_fontInfoScanner = new FontInfoScanner(&(doc->doc));
+	    int numEmb = doc->doc.getCatalog()->numEmbeddedFiles();
+	    if (!(0 == numEmb)) {
+		// we have some embedded documents, build the list
+		for (int yalv = 0; yalv < numEmb; ++yalv) {
+		    EmbFile *ef = doc->doc.getCatalog()->embeddedFile(yalv);
+		    pdoc->m_doc->m_embeddedFiles.append(new EmbeddedFile(ef));
+		    delete ef;
+		}
+	    }
 	    return pdoc;
 	}
 	else
@@ -150,6 +162,11 @@
 	return ourList;
     }
 
+    const QList<EmbeddedFile*> &Document::embeddedFiles() const
+    {
+	return m_doc->m_embeddedFiles;
+    }
+
     bool Document::scanForFonts( int numPages, QList<FontInfo> *fontList ) const
     {
 	GooList *items = m_doc->m_fontInfoScanner->scan( numPages );
@@ -257,7 +274,7 @@
 	Dict *infoDict = info.getDict();
 	// somehow iterate over keys in infoDict
 	for( int i=0; i < infoDict->getLength(); ++i ) {
-	    keys.append( QString::fromAscii(infoDict->getKey(i)) );
+	    keys.append( QString::fromAscii(infoDict->getKey(i)->getCString()) );
 	}
 
 	info.free();
@@ -279,8 +296,6 @@
 	}
 
 	Object obj;
-	char *s;
-	int year, mon, day, hour, min, sec;
 	Dict *infoDict = info.getDict();
 	QDateTime result;
 
@@ -364,6 +379,11 @@
 	return page(index);
     }
 
+    bool Document::hasEmbeddedFiles() const
+    {
+	return (!(0 == m_doc->doc.getCatalog()->numEmbeddedFiles()));
+    }
+
     QDateTime convertDate( char *dateString )
     {
         int year;
diff -Nur poppler.0_5_0/qt4/src/poppler-embeddedfile.cc poppler.HEAD/qt4/src/poppler-embeddedfile.cc
--- poppler.0_5_0/qt4/src/poppler-embeddedfile.cc	1970-01-01 01:00:00.000000000 +0100
+++ poppler.HEAD/qt4/src/poppler-embeddedfile.cc	2006-01-18 23:38:59.000000000 +0100
@@ -0,0 +1,106 @@
+/* poppler-document.cc: qt interface to poppler
+ * Copyright (C) 2005, Albert Astals Cid <aacid@kde.org>
+ * Copyright (C) 2005, Brad Hards <bradh@frogmouth.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#define UNSTABLE_POPPLER_QT4
+
+#include <QtCore/QString>
+#include <QtCore/QDateTime>
+
+#include "Object.h"
+#include "Stream.h"
+#include "Catalog.h"
+
+#include "poppler-qt4.h"
+
+namespace Poppler
+{
+
+class EmbeddedFileData
+{
+public:
+	QString m_label;
+	QString m_description;
+	QDateTime m_modDate;
+	QDateTime m_createDate;
+	Object m_streamObject;
+};
+
+EmbeddedFile::EmbeddedFile(EmbFile *embfile)
+{
+	m_embeddedFile = new EmbeddedFileData();
+	m_embeddedFile->m_label = QString(embfile->name()->getCString());
+	m_embeddedFile->m_description = QString(embfile->description()->getCString());
+	m_embeddedFile->m_modDate = convertDate(embfile->modDate()->getCString());
+	m_embeddedFile->m_createDate = convertDate(embfile->createDate()->getCString());
+	embfile->streamObject().copy(&m_embeddedFile->m_streamObject);
+}
+
+EmbeddedFile::EmbeddedFile(const EmbeddedFile &ef)
+{
+	m_embeddedFile = new EmbeddedFileData();
+	m_embeddedFile->m_label = ef.m_embeddedFile->m_label;
+	m_embeddedFile->m_description = ef.m_embeddedFile->m_description;
+	m_embeddedFile->m_modDate = ef.m_embeddedFile->m_modDate;
+	m_embeddedFile->m_createDate = ef.m_embeddedFile->m_createDate;
+	ef.m_embeddedFile->m_streamObject.copy(&m_embeddedFile->m_streamObject);
+}
+
+EmbeddedFile::~EmbeddedFile()
+{
+	m_embeddedFile->m_streamObject.free();
+	delete m_embeddedFile;
+}
+
+QString EmbeddedFile::name() const
+{
+	return m_embeddedFile->m_label;
+}
+
+QString EmbeddedFile::description() const
+{
+	return m_embeddedFile->m_description;
+}
+
+QDateTime EmbeddedFile::modDate() const
+{
+	return m_embeddedFile->m_modDate;
+}
+
+QDateTime EmbeddedFile::createDate() const
+{
+	return m_embeddedFile->m_createDate;
+}
+
+QByteArray EmbeddedFile::data()
+{
+	Object obj;
+	Stream *stream = m_embeddedFile->m_streamObject.getStream();
+	stream->reset();
+	int dataLen = 0;
+	QByteArray fileArray;
+	int i;
+	while ( (i = stream->getChar()) != EOF) {
+		fileArray[dataLen] = (char)i;
+		++dataLen;
+	}
+	fileArray.resize(dataLen);
+	return fileArray;
+};
+
+}
diff -Nur poppler.0_5_0/qt4/src/poppler-page.cc poppler.HEAD/qt4/src/poppler-page.cc
--- poppler.0_5_0/qt4/src/poppler-page.cc	2006-01-05 14:53:58.000000000 +0100
+++ poppler.HEAD/qt4/src/poppler-page.cc	2006-01-10 22:57:28.000000000 +0100
@@ -26,12 +26,12 @@
 #include <Catalog.h>
 #include <ErrorCodes.h>
 #include <ArthurOutputDev.h>
-#include <Private.h>
 #include <SplashOutputDev.h>
 #include <TextOutputDev.h>
 #include <splash/SplashBitmap.h>
 
 #include "poppler-private.h"
+#include "poppler-page-transition-private.h"
 
 namespace Poppler {
 
diff -Nur poppler.0_5_0/qt4/src/poppler-private.h poppler.HEAD/qt4/src/poppler-private.h
--- poppler.0_5_0/qt4/src/poppler-private.h	2006-01-01 23:35:48.000000000 +0100
+++ poppler.HEAD/qt4/src/poppler-private.h	2006-01-18 23:32:13.000000000 +0100
@@ -34,6 +34,7 @@
 	
 	~DocumentData()
 	{
+		qDeleteAll(m_embeddedFiles);
 		delete m_splashOutputDev;
 		delete m_fontInfoScanner;
 	}
@@ -56,6 +57,7 @@
 	bool locked;
 	FontInfoScanner *m_fontInfoScanner;
 	SplashOutputDev *m_splashOutputDev;
+	QList<EmbeddedFile*> m_embeddedFiles;
     };
 
 }
diff -Nur poppler.0_5_0/qt4/src/poppler-qt4.h poppler.HEAD/qt4/src/poppler-qt4.h
--- poppler.0_5_0/qt4/src/poppler-qt4.h	2006-01-05 14:53:58.000000000 +0100
+++ poppler.HEAD/qt4/src/poppler-qt4.h	2006-01-18 23:32:13.000000000 +0100
@@ -26,7 +26,9 @@
 #include <QtCore/QDateTime>
 #include <QtGui/QPixmap>
 
-#include <PageTransition.h>
+#include <poppler-page-transition.h>
+
+class EmbFile;
 
 /**
    The Poppler Qt bindings
@@ -146,6 +148,58 @@
 
 
     /**
+       Container class for an embedded file with a PDF document
+    */
+    class EmbeddedFileData;
+    class EmbeddedFile {
+    public:
+	/**
+	   Create a new embedded file container
+	*/
+	EmbeddedFile(EmbFile *embfile);
+	
+	EmbeddedFile(const EmbeddedFile &ef);
+	
+	~EmbeddedFile();
+
+	/**
+	   The name associated with the file
+	*/
+	QString name() const;
+
+	/**
+	   The description associated with the file, if any.
+
+	   This will return an empty QString if there is no description element
+	*/
+	QString description() const;
+
+	/**
+	   The modification date for the embedded file, if known.
+	*/
+	QDateTime modDate() const;
+
+	/**
+	   The creation date for the embedded file, if known.
+	*/
+	QDateTime createDate() const;
+
+	/**
+	   The data as an array
+	*/
+	QByteArray data();
+
+	/**
+	   A QDataStream for the actual data?
+	*/
+	//QDataStream dataStream() const;
+
+    private:
+	EmbeddedFileData *m_embeddedFile;
+    };
+
+
+    /**
        Page within a PDF document
     */
     class Page {
@@ -544,6 +598,20 @@
 	*/
 	bool scanForFonts( int numPages, QList<FontInfo> *fontList ) const; 
 
+
+	/**
+	   The documents embedded within the PDF document.
+
+	   \note there are two types of embedded document - this call
+	   only accesses documents that are embedded at the document level.
+	*/
+	const QList<EmbeddedFile*> &embeddedFiles() const;
+
+	/**
+	   Whether there are any documents embedded in this PDF document.
+	*/
+	bool hasEmbeddedFiles() const;
+
 	Document::~Document();
   
     private:
diff -Nur poppler.0_5_0/qt4/tests/check_attachments.cpp poppler.HEAD/qt4/tests/check_attachments.cpp
--- poppler.0_5_0/qt4/tests/check_attachments.cpp	1970-01-01 01:00:00.000000000 +0100
+++ poppler.HEAD/qt4/tests/check_attachments.cpp	2006-01-18 23:40:26.000000000 +0100
@@ -0,0 +1,151 @@
+#include <QtTest/QtTest>
+
+#define UNSTABLE_POPPLER_QT4
+#include <poppler-qt4.h>
+
+#include <QtCore/QFile>
+
+class TestAttachments: public QObject
+{
+    Q_OBJECT
+private slots:
+    void checkNoAttachments();
+    void checkAttach1();
+    void checkAttach2();
+    void checkAttach3();
+    void checkAttach4();
+};
+
+void TestAttachments::checkNoAttachments()
+{
+    Poppler::Document *doc;
+    doc = Poppler::Document::load("../../../test/unittestcases/truetype.pdf");
+    QVERIFY( doc );
+
+    QCOMPARE( doc->hasEmbeddedFiles(), false );
+
+    delete doc;
+}
+
+void TestAttachments::checkAttach1()
+{
+
+    Poppler::Document *doc;
+    doc = Poppler::Document::load("../../../test/unittestcases/WithAttachments.pdf");
+    QVERIFY( doc );
+
+    QVERIFY( doc->hasEmbeddedFiles() );
+
+    QList<Poppler::EmbeddedFile*> fileList = doc->embeddedFiles();
+    QCOMPARE( fileList.size(), 2 );
+
+    Poppler::EmbeddedFile *embfile = fileList.at(0);
+    QCOMPARE( embfile->name(), QString( "kroller.png" ) );
+    QCOMPARE( embfile->description(), QString("/home/bradh/coding/svn-vers/KDE/kdeartwork/wallpapers/kroller.png") );
+    QCOMPARE( embfile->createDate(), QDateTime( QDate(), QTime() ) );
+    QCOMPARE( embfile->modDate(), QDateTime( QDate(), QTime() ) );
+
+    QFile file( "../../../test/unittestcases/kroller.png" );
+    QVERIFY(  file.open( QIODevice::ReadOnly ) );
+    QByteArray krollerData = file.readAll();
+    QByteArray embdata = embfile->data();
+    QCOMPARE( krollerData, embdata );
+	    
+
+    Poppler::EmbeddedFile *embfile2 = fileList.at(1);
+    QCOMPARE( embfile2->name(), QString("gnome-64.gif") );
+    QCOMPARE( embfile2->description(), QString("/usr/share/gnome-about/gnome-64.gif") );
+    QCOMPARE( embfile2->modDate(), QDateTime( QDate(), QTime() ) );
+    QCOMPARE( embfile2->createDate(), QDateTime( QDate(), QTime() ) );
+
+    QFile file2( "../../../test/unittestcases/gnome-64.gif" );
+    QVERIFY(  file2.open( QIODevice::ReadOnly ) );
+    QByteArray g64Data = file2.readAll();
+    QByteArray emb2data = embfile2->data();
+    QCOMPARE( g64Data, emb2data );
+
+    delete doc;
+}
+
+
+void TestAttachments::checkAttach2()
+{
+
+    Poppler::Document *doc;
+    doc = Poppler::Document::load("../../../test/unittestcases/A6EmbeddedFiles.pdf");
+    QVERIFY( doc );
+
+    QVERIFY( doc->hasEmbeddedFiles() );
+
+    QList<Poppler::EmbeddedFile*> fileList;
+    fileList = doc->embeddedFiles();
+    QCOMPARE( fileList.size(), 3 );
+
+    Poppler::EmbeddedFile *embfile1 = fileList.at(0);
+    QCOMPARE( embfile1->name(), QString("Acro7 thoughts") );
+    QCOMPARE( embfile1->description(), QString("Acro7 Thoughts") );
+    QCOMPARE( embfile1->createDate(), QDateTime( QDate( 2003, 8, 4 ), QTime( 13, 54, 54), Qt::UTC ) );
+    QCOMPARE( embfile1->modDate(), QDateTime( QDate( 2003, 8, 4 ), QTime( 14, 15, 27), Qt::UTC ) );
+
+    Poppler::EmbeddedFile *embfile2 = fileList.at(1);
+    QCOMPARE( embfile2->name(), QString("acro transitions 1.xls") );
+    QCOMPARE( embfile2->description(), QString("AcroTransitions") );
+    QCOMPARE( embfile2->createDate(), QDateTime( QDate( 2003, 7, 18 ), QTime( 21, 7, 16), Qt::UTC ) );
+    QCOMPARE( embfile2->modDate(), QDateTime( QDate( 2003, 7, 22 ), QTime( 13, 4, 40), Qt::UTC ) );
+
+    Poppler::EmbeddedFile *embfile3 = fileList.at(2);
+    QCOMPARE( embfile3->name(), QString("apago_pdfe_wide.gif") );
+    QCOMPARE( embfile3->description(), QString("PDFE Animation") );
+    QCOMPARE( embfile3->createDate(), QDateTime( QDate( 2003, 1, 31 ), QTime( 15, 54, 29), Qt::UTC ) );
+    QCOMPARE( embfile3->modDate(), QDateTime( QDate( 2003, 1, 31 ), QTime( 15, 52, 58), Qt::UTC ) );
+
+    delete doc;
+}
+
+void TestAttachments::checkAttach3()
+{
+
+    Poppler::Document *doc;
+    doc = Poppler::Document::load("../../../test/unittestcases/shapes+attachments.pdf");
+    QVERIFY( doc );
+
+    QVERIFY( doc->hasEmbeddedFiles() );
+
+    QList<Poppler::EmbeddedFile*> fileList;
+    fileList = doc->embeddedFiles();
+    QCOMPARE( fileList.size(), 1 );
+
+    Poppler::EmbeddedFile *embfile = fileList.at(0);
+    QCOMPARE( embfile->name(), QString( "ADEX1.xpdf.pgp" ) );
+    QCOMPARE( embfile->description(), QString("encrypted version of document") );
+    QCOMPARE( embfile->createDate(), QDateTime( QDate( 2004, 3, 29 ), QTime( 19, 37, 16), Qt::UTC ) );
+    QCOMPARE( embfile->modDate(), QDateTime( QDate( 2004, 3, 29 ), QTime( 19, 37, 16), Qt::UTC ) );
+    delete doc;
+
+}
+
+void TestAttachments::checkAttach4()
+{
+
+    Poppler::Document *doc;
+    doc = Poppler::Document::load("../../../test/unittestcases/imageretrieve+attachment.pdf");
+    QVERIFY( doc );
+
+    QVERIFY( doc->hasEmbeddedFiles() );
+
+    QList<Poppler::EmbeddedFile*> fileList;
+    fileList = doc->embeddedFiles();
+    QCOMPARE( fileList.size(), 1 );
+
+    Poppler::EmbeddedFile *embfile = fileList.at(0);
+    QCOMPARE( embfile->name(), QString( "export-altona.csv" ) );
+    QCOMPARE( embfile->description(), QString("Altona Export") );
+    QCOMPARE( embfile->createDate(), QDateTime( QDate( 2005, 8, 30 ), QTime( 20, 49, 35), Qt::UTC ) );
+    QCOMPARE( embfile->modDate(), QDateTime( QDate( 2005, 8, 30 ), QTime( 20, 49, 52), Qt::UTC ) );
+    delete doc;
+
+}
+
+QTEST_MAIN(TestAttachments)
+#include "check_attachments.moc"
+
diff -Nur poppler.0_5_0/qt4/tests/Makefile.am poppler.HEAD/qt4/tests/Makefile.am
--- poppler.0_5_0/qt4/tests/Makefile.am	2005-12-27 07:10:02.000000000 +0100
+++ poppler.HEAD/qt4/tests/Makefile.am	2006-01-18 23:32:13.000000000 +0100
@@ -2,6 +2,7 @@
 	-I$(top_srcdir)				\
 	-I$(top_srcdir)/poppler			\
 	-I$(top_srcdir)/qt4/src			\
+	-I$(top_srcdir)/qt			\
 	$(POPPLER_QT4_CXXFLAGS)			\
 	$(POPPLER_QTTEST_CXXFLAGS)
 
@@ -18,7 +19,7 @@
 	moc -i $< -o $@
 
 noinst_PROGRAMS = test-poppler-qt4 stress-poppler-qt4 \
-	poppler-fonts test-password-qt4
+	poppler-fonts test-password-qt4 poppler-attachments
 
 
 test_poppler_qt4_SOURCES =			\
@@ -38,6 +39,11 @@
 
 poppler_fonts_LDADD = $(LDADDS)
 
+poppler_attachments_SOURCES =			\
+       poppler-attachments.cpp
+
+poppler_attachments_LDADD = $(LDADDS)
+
 
 stress_poppler_qt4_SOURCES =			\
        stress-poppler-qt4.cpp
@@ -46,7 +52,8 @@
 
 if BUILD_POPPLER_QT4TESTS
 TESTS = \
-	check_dateConversion	\
+	check_attachments	\
+	check_dateConversion 	\
 	check_fonts		\
 	check_metadata         	\
 	check_permissions      	\
@@ -55,6 +62,10 @@
 
 check_PROGRAMS = $(TESTS)
 
+check_attachments_SOURCES = check_attachments.cpp
+check_attachments.$(OBJEXT): check_attachments.moc
+check_attachments_LDADD = $(UT_LDADDS)
+
 check_dateConversion_SOURCES = check_dateConversion.cpp
 check_dateConversion.$(OBJEXT): check_dateConversion.moc
 check_dateConversion_LDADD = $(UT_LDADDS)
@@ -72,7 +83,7 @@
 check_pagemode_LDADD = $(UT_LDADDS)
 
 check_permissions_SOURCES = check_permissions.cpp
-check_metadata.$(OBJEXT): check_permissions.moc
+check_permissions.$(OBJEXT): check_permissions.moc
 check_permissions_LDADD = $(UT_LDADDS)
 
 check_pagelayout_SOURCES = check_pagelayout.cpp
diff -Nur poppler.0_5_0/qt4/tests/poppler-attachments.cpp poppler.HEAD/qt4/tests/poppler-attachments.cpp
--- poppler.0_5_0/qt4/tests/poppler-attachments.cpp	1970-01-01 01:00:00.000000000 +0100
+++ poppler.HEAD/qt4/tests/poppler-attachments.cpp	2006-01-18 23:40:26.000000000 +0100
@@ -0,0 +1,37 @@
+#include <QtCore/QtCore>
+#include <iostream>
+
+#define UNSTABLE_POPPLER_QT4
+#include <poppler-qt4.h>
+
+int main( int argc, char **argv )
+{
+    QCoreApplication a( argc, argv );               // QApplication required!
+
+    if (!( argc == 2 ))
+    {
+	qWarning() << "usage: poppler-attachments filename";
+	exit(1);
+    }
+  
+    Poppler::Document *doc = Poppler::Document::load(argv[1]);
+    if (!doc)
+    {
+	qWarning() << "doc not loaded";
+	exit(1);
+    }
+
+    if (doc->hasEmbeddedFiles()) {
+	std::cout << "Embedded files: " << std::endl;
+	foreach(Poppler::EmbeddedFile *file, doc->embeddedFiles()) {
+	    std::cout << "    " << qPrintable(file->name()) << std::endl;
+	    std::cout << "    desc:" << qPrintable(file->description()) << std::endl;
+	    QByteArray data = file->data();
+	    std::cout << "       data: " << data.constData() << std::endl;
+	}
+	
+    } else {
+	std::cout << "There are no embedded document at the top level" << std::endl;
+    }
+  
+}
diff -Nur poppler.0_5_0/splash/Splash.cc poppler.HEAD/splash/Splash.cc
--- poppler.0_5_0/splash/Splash.cc	2005-10-30 21:29:05.000000000 +0100
+++ poppler.HEAD/splash/Splash.cc	2006-02-06 21:49:21.000000000 +0100
@@ -2020,10 +2020,10 @@
 	  for (xx = 0, x1 = x0 - glyph->x; xx < glyph->w; ++xx, ++x1) {
 	    alpha = *p++;
 	    if (softMask) {
-	      alpha = (int)(alpha * state->fillAlpha *
+	      alpha = (int)(alpha * (float)state->fillAlpha *
 			    softMask->data[y1 * softMask->rowSize + x1]);
 	    } else {
-	      alpha = (int)(alpha * state->fillAlpha);
+	      alpha = (int)(alpha * (float)state->fillAlpha);
 	    }
 	    if (alpha > 0) {
 	      if (noClip || state->clip->test(x1, y1)) {
diff -Nur poppler.0_5_0/splash/SplashFontEngine.cc poppler.HEAD/splash/SplashFontEngine.cc
--- poppler.0_5_0/splash/SplashFontEngine.cc	2005-09-16 19:42:56.000000000 +0200
+++ poppler.HEAD/splash/SplashFontEngine.cc	2006-02-02 23:50:01.000000000 +0100
@@ -105,19 +105,19 @@
 }
 
 SplashFontFile *SplashFontEngine::loadType1Font(SplashFontFileID *idA,
-						char *fileName,
-						GBool deleteFile, char **enc) {
+						SplashFontSrc *src,
+						char **enc) {
   SplashFontFile *fontFile;
 
   fontFile = NULL;
 #if HAVE_T1LIB_H
   if (!fontFile && t1Engine) {
-    fontFile = t1Engine->loadType1Font(idA, fileName, deleteFile, enc);
+    fontFile = t1Engine->loadType1Font(idA, src, enc);
   }
 #endif
 #if HAVE_FREETYPE_FREETYPE_H || HAVE_FREETYPE_H
   if (!fontFile && ftEngine) {
-    fontFile = ftEngine->loadType1Font(idA, fileName, deleteFile, enc);
+    fontFile = ftEngine->loadType1Font(idA, src, enc);
   }
 #endif
 
@@ -126,29 +126,26 @@
   // semantics, this will remove the last link; otherwise it will
   // return an error, leaving the file to be deleted later (if
   // loadXYZFont failed, the file will always be deleted)
-  if (deleteFile) {
-    unlink(fontFile ? fontFile->fileName->getCString() : fileName);
-  }
+  src->unref();
 #endif
 
   return fontFile;
 }
 
 SplashFontFile *SplashFontEngine::loadType1CFont(SplashFontFileID *idA,
-						 char *fileName,
-						 GBool deleteFile,
+						 SplashFontSrc *src,
 						 char **enc) {
   SplashFontFile *fontFile;
 
   fontFile = NULL;
 #if HAVE_T1LIB_H
   if (!fontFile && t1Engine) {
-    fontFile = t1Engine->loadType1CFont(idA, fileName, deleteFile, enc);
+    fontFile = t1Engine->loadType1CFont(idA, src, enc);
   }
 #endif
 #if HAVE_FREETYPE_FREETYPE_H || HAVE_FREETYPE_H
   if (!fontFile && ftEngine) {
-    fontFile = ftEngine->loadType1CFont(idA, fileName, deleteFile, enc);
+    fontFile = ftEngine->loadType1CFont(idA, src, enc);
   }
 #endif
 
@@ -157,23 +154,20 @@
   // semantics, this will remove the last link; otherwise it will
   // return an error, leaving the file to be deleted later (if
   // loadXYZFont failed, the file will always be deleted)
-  if (deleteFile) {
-    unlink(fontFile ? fontFile->fileName->getCString() : fileName);
-  }
+  src->unref();
 #endif
 
   return fontFile;
 }
 
 SplashFontFile *SplashFontEngine::loadCIDFont(SplashFontFileID *idA,
-					      char *fileName,
-					      GBool deleteFile) {
+					      SplashFontSrc *src) {
   SplashFontFile *fontFile;
 
   fontFile = NULL;
 #if HAVE_FREETYPE_FREETYPE_H || HAVE_FREETYPE_H
   if (!fontFile && ftEngine) {
-    fontFile = ftEngine->loadCIDFont(idA, fileName, deleteFile);
+    fontFile = ftEngine->loadCIDFont(idA, src);
   }
 #endif
 
@@ -182,26 +176,24 @@
   // semantics, this will remove the last link; otherwise it will
   // return an error, leaving the file to be deleted later (if
   // loadXYZFont failed, the file will always be deleted)
-  if (deleteFile) {
-    unlink(fontFile ? fontFile->fileName->getCString() : fileName);
-  }
+  src->unref();
 #endif
 
   return fontFile;
 }
 
 SplashFontFile *SplashFontEngine::loadTrueTypeFont(SplashFontFileID *idA,
-						   char *fileName,
-						   GBool deleteFile,
+						   SplashFontSrc *src,
 						   Gushort *codeToGID,
-						   int codeToGIDLen) {
+						   int codeToGIDLen,
+						   int faceIndex) {
   SplashFontFile *fontFile;
 
   fontFile = NULL;
 #if HAVE_FREETYPE_FREETYPE_H || HAVE_FREETYPE_H
   if (!fontFile && ftEngine) {
-    fontFile = ftEngine->loadTrueTypeFont(idA, fileName, deleteFile,
-					  codeToGID, codeToGIDLen);
+    fontFile = ftEngine->loadTrueTypeFont(idA, src,
+                                        codeToGID, codeToGIDLen, faceIndex);
   }
 #endif
 
@@ -214,9 +206,7 @@
   // semantics, this will remove the last link; otherwise it will
   // return an error, leaving the file to be deleted later (if
   // loadXYZFont failed, the file will always be deleted)
-  if (deleteFile) {
-    unlink(fontFile ? fontFile->fileName->getCString() : fileName);
-  }
+  src->unref();
 #endif
 
   return fontFile;
diff -Nur poppler.0_5_0/splash/SplashFontEngine.h poppler.HEAD/splash/SplashFontEngine.h
--- poppler.0_5_0/splash/SplashFontEngine.h	2005-03-03 20:45:59.000000000 +0100
+++ poppler.HEAD/splash/SplashFontEngine.h	2006-02-02 23:50:01.000000000 +0100
@@ -19,6 +19,7 @@
 class SplashFontFile;
 class SplashFontFileID;
 class SplashFont;
+class SplashFontSrc;
 
 //------------------------------------------------------------------------
 
@@ -48,15 +49,12 @@
   SplashFontFile *getFontFile(SplashFontFileID *id);
 
   // Load fonts - these create new SplashFontFile objects.
-  SplashFontFile *loadType1Font(SplashFontFileID *idA, char *fileName,
-				GBool deleteFile, char **enc);
-  SplashFontFile *loadType1CFont(SplashFontFileID *idA, char *fileName,
-				 GBool deleteFile, char **enc);
-  SplashFontFile *loadCIDFont(SplashFontFileID *idA, char *fileName,
-			      GBool deleteFile);
-  SplashFontFile *loadTrueTypeFont(SplashFontFileID *idA, char *fileName,
-				   GBool deleteFile,
-				   Gushort *codeToGID, int codeToGIDLen);
+  SplashFontFile *loadType1Font(SplashFontFileID *idA, SplashFontSrc *src, char **enc);
+  SplashFontFile *loadType1CFont(SplashFontFileID *idA, SplashFontSrc *src, char **enc);
+  SplashFontFile *loadCIDFont(SplashFontFileID *idA, SplashFontSrc *src);
+  SplashFontFile *loadTrueTypeFont(SplashFontFileID *idA, SplashFontSrc *src,
+				   Gushort *codeToGID, int codeToGIDLen,
+				   int faceIndex=0);
 
   // Get a font - this does a cache lookup first, and if not found,
   // creates a new SplashFont object and adds it to the cache.  The
diff -Nur poppler.0_5_0/splash/SplashFontFile.cc poppler.HEAD/splash/SplashFontFile.cc
--- poppler.0_5_0/splash/SplashFontFile.cc	2005-12-08 19:17:42.000000000 +0100
+++ poppler.HEAD/splash/SplashFontFile.cc	2006-02-02 23:50:01.000000000 +0100
@@ -12,6 +12,7 @@
 
 #include <stdio.h>
 #include <unistd.h>
+#include "goo/gmem.h"
 #include "goo/GooString.h"
 #include "SplashFontFile.h"
 #include "SplashFontFileID.h"
@@ -26,19 +27,15 @@
 // SplashFontFile
 //------------------------------------------------------------------------
 
-SplashFontFile::SplashFontFile(SplashFontFileID *idA, char *fileNameA,
-			       GBool deleteFileA) {
+SplashFontFile::SplashFontFile(SplashFontFileID *idA, SplashFontSrc *srcA) {
   id = idA;
-  fileName = new GooString(fileNameA);
-  deleteFile = deleteFileA;
+  src = srcA;
+  src->ref();
   refCnt = 0;
 }
 
 SplashFontFile::~SplashFontFile() {
-  if (deleteFile) {
-    unlink(fileName->getCString());
-  }
-  delete fileName;
+  src->unref();
   delete id;
 }
 
@@ -51,3 +48,60 @@
     delete this;
   }
 }
+
+//
+
+SplashFontSrc::SplashFontSrc() {
+  isFile = gFalse;
+  deleteSrc = gFalse;
+  fileName = NULL;
+  buf = NULL;
+  refcnt = 1;
+}
+
+SplashFontSrc::~SplashFontSrc() {
+  if (deleteSrc) {
+    if (isFile) {
+      if (fileName)
+	unlink(fileName->getCString());
+    } else {
+      if (buf)
+	gfree(buf);
+    }
+  }
+
+  if (isFile && fileName)
+    delete fileName;
+}
+
+void SplashFontSrc::ref() {
+  refcnt++;
+}
+
+void SplashFontSrc::unref() {
+  if (! --refcnt)
+    delete this;
+}
+
+void SplashFontSrc::setFile(GooString *file, GBool del)
+{
+  isFile = gTrue;
+  fileName = file->copy();
+  deleteSrc = del;
+}
+
+void SplashFontSrc::setFile(const char *file, GBool del)
+{
+  isFile = gTrue;
+  fileName = new GooString(file);
+  deleteSrc = del;
+}
+
+void SplashFontSrc::setBuf(char *bufA, int bufLenA, GBool del)
+{
+  isFile = gFalse;
+  buf = bufA;
+  bufLen = bufLenA;
+  deleteSrc = del;
+}
+
diff -Nur poppler.0_5_0/splash/SplashFontFile.h poppler.HEAD/splash/SplashFontFile.h
--- poppler.0_5_0/splash/SplashFontFile.h	2005-03-03 20:45:59.000000000 +0100
+++ poppler.HEAD/splash/SplashFontFile.h	2006-02-02 23:50:01.000000000 +0100
@@ -23,6 +23,25 @@
 // SplashFontFile
 //------------------------------------------------------------------------
 
+struct SplashFontSrc {
+  SplashFontSrc();
+  ~SplashFontSrc();
+
+  void setFile(GooString *file, GBool del);
+  void setFile(const char *file, GBool del);
+  void setBuf(char *bufA, int buflenA, GBool del);
+
+  void ref();
+  void unref();
+
+  GBool isFile;
+  GooString *fileName;
+  char *buf;
+  int bufLen;
+  GBool deleteSrc;
+  int refcnt;
+};
+
 class SplashFontFile {
 public:
 
@@ -44,12 +63,10 @@
 
 protected:
 
-  SplashFontFile(SplashFontFileID *idA, char *fileNameA,
-		 GBool deleteFileA);
+  SplashFontFile(SplashFontFileID *idA, SplashFontSrc *srcA);
 
   SplashFontFileID *id;
-  GooString *fileName;
-  GBool deleteFile;
+  SplashFontSrc *src;
   int refCnt;
 
   friend class SplashFontEngine;
diff -Nur poppler.0_5_0/splash/SplashFTFont.cc poppler.HEAD/splash/SplashFTFont.cc
--- poppler.0_5_0/splash/SplashFTFont.cc	2005-11-17 22:37:34.000000000 +0100
+++ poppler.HEAD/splash/SplashFTFont.cc	2006-01-23 15:45:30.000000000 +0100
@@ -19,7 +19,8 @@
 
 #include <ft2build.h>
 #include FT_OUTLINE_H
-#include FT_INTERNAL_OBJECTS_H // needed for FT_New_Size decl
+#include FT_SIZES_H
+#include FT_GLYPH_H
 #include "goo/gmem.h"
 #include "SplashMath.h"
 #include "SplashGlyphBitmap.h"
diff -Nur poppler.0_5_0/splash/SplashFTFontEngine.cc poppler.HEAD/splash/SplashFTFontEngine.cc
--- poppler.0_5_0/splash/SplashFTFontEngine.cc	2005-12-08 19:17:42.000000000 +0100
+++ poppler.HEAD/splash/SplashFTFontEngine.cc	2006-02-02 23:50:01.000000000 +0100
@@ -64,22 +64,19 @@
 }
 
 SplashFontFile *SplashFTFontEngine::loadType1Font(SplashFontFileID *idA,
-						  char *fileName,
-						  GBool deleteFile,
+						  SplashFontSrc *src,
 						  char **enc) {
-  return SplashFTFontFile::loadType1Font(this, idA, fileName, deleteFile, enc);
+  return SplashFTFontFile::loadType1Font(this, idA, src, enc);
 }
 
 SplashFontFile *SplashFTFontEngine::loadType1CFont(SplashFontFileID *idA,
-						   char *fileName,
-						   GBool deleteFile,
+						   SplashFontSrc *src,
 						   char **enc) {
-  return SplashFTFontFile::loadType1Font(this, idA, fileName, deleteFile, enc);
+  return SplashFTFontFile::loadType1Font(this, idA, src, enc);
 }
 
 SplashFontFile *SplashFTFontEngine::loadCIDFont(SplashFontFileID *idA,
-						char *fileName,
-						GBool deleteFile) {
+						SplashFontSrc *src) {
   FoFiType1C *ff;
   Gushort *cidToGIDMap;
   int nCIDs;
@@ -89,15 +86,21 @@
   if (useCIDs) {
     cidToGIDMap = NULL;
     nCIDs = 0;
-  } else if ((ff = FoFiType1C::load(fileName))) {
+  } else {
+    if (src->isFile) {
+      ff = FoFiType1C::load(src->fileName->getCString());
+    } else {
+      ff = new FoFiType1C(src->buf, src->bufLen, gFalse);
+    }
+    if (ff) {
     cidToGIDMap = ff->getCIDToGIDMap(&nCIDs);
     delete ff;
   } else {
     cidToGIDMap = NULL;
     nCIDs = 0;
   }
-  ret = SplashFTFontFile::loadCIDFont(this, idA, fileName, deleteFile,
-				      cidToGIDMap, nCIDs);
+  }
+  ret = SplashFTFontFile::loadCIDFont(this, idA, src, cidToGIDMap, nCIDs);
   if (!ret) {
     gfree(cidToGIDMap);
   }
@@ -105,16 +108,17 @@
 }
 
 SplashFontFile *SplashFTFontEngine::loadTrueTypeFont(SplashFontFileID *idA,
-						     char *fileName,
-						     GBool deleteFile,
+						     SplashFontSrc *src,
 						     Gushort *codeToGID,
-						     int codeToGIDLen) {
+						     int codeToGIDLen,
+						     int faceIndex) {
+#if 0
   FoFiTrueType *ff;
   GooString *tmpFileName;
   FILE *tmpFile;
   SplashFontFile *ret;
 
-  if (!(ff = FoFiTrueType::load(fileName))) {
+  if (!(ff = FoFiTrueType::load(fileName, faceIndex))) {
     return NULL;
   }
   tmpFileName = NULL;
@@ -127,7 +131,8 @@
   fclose(tmpFile);
   ret = SplashFTFontFile::loadTrueTypeFont(this, idA,
 					   tmpFileName->getCString(),
-					   gTrue, codeToGID, codeToGIDLen);
+					   gTrue, codeToGID, codeToGIDLen,
+					   faceIndex);
   if (ret) {
     if (deleteFile) {
       unlink(fileName);
@@ -137,6 +142,13 @@
   }
   delete tmpFileName;
   return ret;
+#else
+  SplashFontFile *ret;
+  ret = SplashFTFontFile::loadTrueTypeFont(this, idA, src,
+					   codeToGID, codeToGIDLen,
+					   faceIndex);
+  return ret;
+#endif
 }
 
 #endif // HAVE_FREETYPE_FREETYPE_H || HAVE_FREETYPE_H
diff -Nur poppler.0_5_0/splash/SplashFTFontEngine.h poppler.HEAD/splash/SplashFTFontEngine.h
--- poppler.0_5_0/splash/SplashFTFontEngine.h	2005-09-16 00:09:50.000000000 +0200
+++ poppler.HEAD/splash/SplashFTFontEngine.h	2006-02-02 23:50:01.000000000 +0100
@@ -19,6 +19,7 @@
 
 class SplashFontFile;
 class SplashFontFileID;
+class SplashFontSrc;
 
 //------------------------------------------------------------------------
 // SplashFTFontEngine
@@ -32,15 +33,12 @@
   ~SplashFTFontEngine();
 
   // Load fonts.
-  SplashFontFile *loadType1Font(SplashFontFileID *idA, char *fileName,
-				GBool deleteFile, char **enc);
-  SplashFontFile *loadType1CFont(SplashFontFileID *idA, char *fileName,
-				 GBool deleteFile, char **enc);
-  SplashFontFile *loadCIDFont(SplashFontFileID *idA, char *fileName,
-			      GBool deleteFile);
-  SplashFontFile *loadTrueTypeFont(SplashFontFileID *idA, char *fileName,
-				   GBool deleteFile,
-				   Gushort *codeToGID, int codeToGIDLen);
+  SplashFontFile *loadType1Font(SplashFontFileID *idA, SplashFontSrc *src, char **enc);
+  SplashFontFile *loadType1CFont(SplashFontFileID *idA, SplashFontSrc *src, char **enc);
+  SplashFontFile *loadCIDFont(SplashFontFileID *idA, SplashFontSrc *src);
+  SplashFontFile *loadTrueTypeFont(SplashFontFileID *idA, SplashFontSrc *src,
+				   Gushort *codeToGID, int codeToGIDLen,
+				   int faceIndex=0);
 
 private:
 
diff -Nur poppler.0_5_0/splash/SplashFTFontFile.cc poppler.HEAD/splash/SplashFTFontFile.cc
--- poppler.0_5_0/splash/SplashFTFontFile.cc	2005-08-27 10:43:43.000000000 +0200
+++ poppler.HEAD/splash/SplashFTFontFile.cc	2006-02-02 23:50:01.000000000 +0100
@@ -13,6 +13,7 @@
 #endif
 
 #include "goo/gmem.h"
+#include "goo/GooString.h"
 #include "SplashFTFontEngine.h"
 #include "SplashFTFont.h"
 #include "SplashFTFontFile.h"
@@ -23,16 +24,19 @@
 
 SplashFontFile *SplashFTFontFile::loadType1Font(SplashFTFontEngine *engineA,
 						SplashFontFileID *idA,
-						char *fileNameA,
-						GBool deleteFileA,
+						SplashFontSrc *src,
 						char **encA) {
   FT_Face faceA;
   Gushort *codeToGIDA;
   char *name;
   int i;
 
-  if (FT_New_Face(engineA->lib, fileNameA, 0, &faceA)) {
-    return NULL;
+  if (src->isFile) {
+    if (FT_New_Face(engineA->lib, src->fileName->getCString(), 0, &faceA))
+      return NULL;
+  } else {
+    if (FT_New_Memory_Face(engineA->lib, (const FT_Byte *)src->buf, src->bufLen, 0, &faceA))
+      return NULL;
   }
   codeToGIDA = (Gushort *)gmallocn(256, sizeof(int));
   for (i = 0; i < 256; ++i) {
@@ -42,48 +46,55 @@
     }
   }
 
-  return new SplashFTFontFile(engineA, idA, fileNameA, deleteFileA,
+  return new SplashFTFontFile(engineA, idA, src,
 			      faceA, codeToGIDA, 256);
 }
 
 SplashFontFile *SplashFTFontFile::loadCIDFont(SplashFTFontEngine *engineA,
 					      SplashFontFileID *idA,
-					      char *fileNameA,
-					      GBool deleteFileA,
+					      SplashFontSrc *src,
 					      Gushort *codeToGIDA,
 					      int codeToGIDLenA) {
   FT_Face faceA;
 
-  if (FT_New_Face(engineA->lib, fileNameA, 0, &faceA)) {
-    return NULL;
+  if (src->isFile) {
+    if (FT_New_Face(engineA->lib, src->fileName->getCString(), 0, &faceA))
+      return NULL;
+  } else {
+    if (FT_New_Memory_Face(engineA->lib, (const FT_Byte *)src->buf, src->bufLen, 0, &faceA))
+      return NULL;
   }
 
-  return new SplashFTFontFile(engineA, idA, fileNameA, deleteFileA,
+  return new SplashFTFontFile(engineA, idA, src,
 			      faceA, codeToGIDA, codeToGIDLenA);
 }
 
 SplashFontFile *SplashFTFontFile::loadTrueTypeFont(SplashFTFontEngine *engineA,
 						   SplashFontFileID *idA,
-						   char *fileNameA,
-						   GBool deleteFileA,
+						   SplashFontSrc *src,
 						   Gushort *codeToGIDA,
-						   int codeToGIDLenA) {
+						   int codeToGIDLenA,
+						   int faceIndexA) {
   FT_Face faceA;
 
-  if (FT_New_Face(engineA->lib, fileNameA, 0, &faceA)) {
-    return NULL;
+  if (src->isFile) {
+    if (FT_New_Face(engineA->lib, src->fileName->getCString(), faceIndexA, &faceA))
+      return NULL;
+  } else {
+    if (FT_New_Memory_Face(engineA->lib, (const FT_Byte *)src->buf, src->bufLen, faceIndexA, &faceA))
+      return NULL;
   }
 
-  return new SplashFTFontFile(engineA, idA, fileNameA, deleteFileA,
+  return new SplashFTFontFile(engineA, idA, src,
 			      faceA, codeToGIDA, codeToGIDLenA);
 }
 
 SplashFTFontFile::SplashFTFontFile(SplashFTFontEngine *engineA,
 				   SplashFontFileID *idA,
-				   char *fileNameA, GBool deleteFileA,
+				   SplashFontSrc *srcA,
 				   FT_Face faceA,
 				   Gushort *codeToGIDA, int codeToGIDLenA):
-  SplashFontFile(idA, fileNameA, deleteFileA)
+  SplashFontFile(idA, srcA)
 {
   engine = engineA;
   face = faceA;
diff -Nur poppler.0_5_0/splash/SplashFTFontFile.h poppler.HEAD/splash/SplashFTFontFile.h
--- poppler.0_5_0/splash/SplashFTFontFile.h	2005-03-03 20:45:59.000000000 +0100
+++ poppler.HEAD/splash/SplashFTFontFile.h	2006-02-02 23:50:01.000000000 +0100
@@ -28,18 +28,18 @@
 public:
 
   static SplashFontFile *loadType1Font(SplashFTFontEngine *engineA,
-				       SplashFontFileID *idA, char *fileNameA,
-				       GBool deleteFileA, char **encA);
+				       SplashFontFileID *idA,
+				       SplashFontSrc *src, char **encA);
   static SplashFontFile *loadCIDFont(SplashFTFontEngine *engineA,
-				     SplashFontFileID *idA, char *fileNameA,
-				     GBool deleteFileA,
-				     Gushort *codeToCIDA, int codeToGIDLenA);
+					 SplashFontFileID *idA,
+					 SplashFontSrc *src,
+					 Gushort *codeToCIDA, int codeToGIDLenA);
   static SplashFontFile *loadTrueTypeFont(SplashFTFontEngine *engineA,
 					  SplashFontFileID *idA,
-					  char *fileNameA,
-					  GBool deleteFileA,
+					  SplashFontSrc *src,
 					  Gushort *codeToGIDA,
-					  int codeToGIDLenA);
+					  int codeToGIDLenA,
+					  int faceIndexA=0);
 
   virtual ~SplashFTFontFile();
 
@@ -51,7 +51,7 @@
 
   SplashFTFontFile(SplashFTFontEngine *engineA,
 		   SplashFontFileID *idA,
-		   char *fileNameA, GBool deleteFileA,
+		   SplashFontSrc *srcA,
 		   FT_Face faceA,
 		   Gushort *codeToGIDA, int codeToGIDLenA);
 
diff -Nur poppler.0_5_0/splash/SplashT1FontEngine.cc poppler.HEAD/splash/SplashT1FontEngine.cc
--- poppler.0_5_0/splash/SplashT1FontEngine.cc	2005-03-03 20:46:00.000000000 +0100
+++ poppler.HEAD/splash/SplashT1FontEngine.cc	2006-02-02 23:50:01.000000000 +0100
@@ -82,22 +82,26 @@
 }
 
 SplashFontFile *SplashT1FontEngine::loadType1Font(SplashFontFileID *idA,
-						  char *fileName,
-						  GBool deleteFile,
+						  SplashFontSrc *src,
 						  char **enc) {
-  return SplashT1FontFile::loadType1Font(this, idA, fileName, deleteFile, enc);
+  return SplashT1FontFile::loadType1Font(this, idA, src, enc);
 }
 
 SplashFontFile *SplashT1FontEngine::loadType1CFont(SplashFontFileID *idA,
-						   char *fileName,
-						   GBool deleteFile,
+						   SplashFontSrc *src,
 						   char **enc) {
   FoFiType1C *ff;
   GooString *tmpFileName;
   FILE *tmpFile;
   SplashFontFile *ret;
 
-  if (!(ff = FoFiType1C::load(fileName))) {
+  SplashFontSrc *newsrc;
+  
+  if (src->isFile)
+    ff = FoFiType1C::load(src->fileName);
+  else
+    ff = new FoFiType1C(src->buf, src->bufLen, gFalse);
+  if (! ff)
     return NULL;
   }
   tmpFileName = NULL;
@@ -108,16 +112,11 @@
   ff->convertToType1(NULL, gTrue, &fileWrite, tmpFile);
   delete ff;
   fclose(tmpFile);
-  ret = SplashT1FontFile::loadType1Font(this, idA, tmpFileName->getCString(),
-					gTrue, enc);
-  if (ret) {
-    if (deleteFile) {
-      unlink(fileName);
-    }
-  } else {
-    unlink(tmpFileName->getCString());
-  }
+  newsrc = new SplashFontSrc;
+  newsrc->setFile(tmpFileName, gTrue);
   delete tmpFileName;
+  ret = SplashT1FontFile::loadType1Font(this, idA, newsrc, enc);
+  newsrc->unref();
   return ret;
 }
 
diff -Nur poppler.0_5_0/splash/SplashT1FontFile.cc poppler.HEAD/splash/SplashT1FontFile.cc
--- poppler.0_5_0/splash/SplashT1FontFile.cc	2005-08-27 10:43:43.000000000 +0200
+++ poppler.HEAD/splash/SplashT1FontFile.cc	2006-02-02 23:50:01.000000000 +0100
@@ -25,8 +25,7 @@
 
 SplashFontFile *SplashT1FontFile::loadType1Font(SplashT1FontEngine *engineA,
 						SplashFontFileID *idA,
-						char *fileNameA,
-						GBool deleteFileA,
+						SplashFontSrc *src,
 						char **encA) {
   int t1libIDA;
   char **encTmp;
@@ -34,9 +33,27 @@
   int encStrSize;
   char *encPtr;
   int i;
-
+  GString *fileNameA;
+  SplashFontSrc *newsrc = NULL;
+  SplashFontFile *ff;
+
+  if (! src->isFile) {
+    GString *tmpFileName;
+    FILE *tmpFile;
+    if (!openTempFile(&tmpFileName, &tmpFile, "wb", NULL))
+      return NULL;
+    fwrite(src->buf, 1, src->bufLen, tmpFile);
+    fclose(tmpFile);
+    newsrc = new SplashFontSrc;
+    newsrc->setFile(tmpFileName, gTrue);
+    src = newsrc;
+    delete tmpFileName;
+  }
+  fileNameA = src->fileName;
   // load the font file
   if ((t1libIDA = T1_AddFont(fileNameA)) < 0) {
+    if (newsrc)
+      delete newsrc;
     return NULL;
   }
   T1_LoadFont(t1libIDA);
@@ -63,15 +80,18 @@
   encTmp[256] = "custom";
   T1_ReencodeFont(t1libIDA, encTmp);
 
-  return new SplashT1FontFile(engineA, idA, fileNameA, deleteFileA,
+  ff = new SplashT1FontFile(engineA, idA, src,
 			      t1libIDA, encTmp, encStrTmp);
+  if (newsrc)
+    newsrc->unref();
+  return ff;
 }
 
 SplashT1FontFile::SplashT1FontFile(SplashT1FontEngine *engineA,
 				   SplashFontFileID *idA,
-				   char *fileNameA, GBool deleteFileA,
+				   SplashFontSrc *srcA,
 				   int t1libIDA, char **encA, char *encStrA):
-  SplashFontFile(idA, fileNameA, deleteFileA)
+  SplashFontFile(idA, srcA)
 {
   engine = engineA;
   t1libID = t1libIDA;
diff -Nur poppler.0_5_0/splash/SplashT1FontFile.h poppler.HEAD/splash/SplashT1FontFile.h
--- poppler.0_5_0/splash/SplashT1FontFile.h	2005-03-03 20:45:59.000000000 +0100
+++ poppler.HEAD/splash/SplashT1FontFile.h	2006-02-02 23:50:01.000000000 +0100
@@ -26,7 +26,7 @@
 
   static SplashFontFile *loadType1Font(SplashT1FontEngine *engineA,
 				       SplashFontFileID *idA,
-				       char *fileNameA, GBool deleteFileA,
+				       SplashFontSrc *src,
 				       char **encA);
 
   virtual ~SplashT1FontFile();
@@ -39,7 +39,7 @@
 
   SplashT1FontFile(SplashT1FontEngine *engineA,
 		   SplashFontFileID *idA,
-		   char *fileNameA, GBool deleteFileA,
+		   SplashFontSrc *src,
 		   int t1libIDA, char **encA, char *encStrA);
 
   SplashT1FontEngine *engine;
diff -Nur poppler.0_5_0/splash/SplashTypes.h poppler.HEAD/splash/SplashTypes.h
--- poppler.0_5_0/splash/SplashTypes.h	2005-10-30 21:29:05.000000000 +0100
+++ poppler.HEAD/splash/SplashTypes.h	2006-02-06 21:49:21.000000000 +0100
@@ -14,7 +14,7 @@
 //------------------------------------------------------------------------
 
 #if USE_FIXEDPOINT
-#include "FixedPoint.h"
+#include "goo/FixedPoint.h"
 typedef FixedPoint SplashCoord;
 #else
 typedef double SplashCoord;
diff -Nur poppler.0_5_0/splash/SplashXPathScanner.cc poppler.HEAD/splash/SplashXPathScanner.cc
--- poppler.0_5_0/splash/SplashXPathScanner.cc	2005-10-16 16:19:47.000000000 +0200
+++ poppler.HEAD/splash/SplashXPathScanner.cc	2006-02-03 00:06:20.000000000 +0100
@@ -186,7 +186,7 @@
 }
 
 void SplashXPathScanner::computeIntersections(int y) {
-  SplashCoord ySegMin, ySegMax, xx0, xx1;
+  SplashCoord xSegMin, xSegMax, ySegMin, ySegMax, xx0, xx1;
   SplashXPathSeg *seg;
   int i, j;
 
@@ -236,19 +236,27 @@
     } else if (seg->flags & splashXPathVert) {
       xx0 = xx1 = seg->x0;
     } else {
-      if (ySegMin <= y) {
-	// intersection with top edge
-	xx0 = seg->x0 + ((SplashCoord)y - seg->y0) * seg->dxdy;
+      if (seg->x0 < seg->x1) {
+	xSegMin = seg->x0;
+	xSegMax = seg->x1;
       } else {
-	// x coord of segment endpoint with min y coord
-	xx0 = (seg->flags & splashXPathFlip) ? seg->x1 : seg->x0;
+	xSegMin = seg->x1;
+	xSegMax = seg->x0;
       }
-      if (ySegMax >= y + 1) {
-	// intersection with bottom edge
-	xx1 = seg->x0 + ((SplashCoord)y + 1 - seg->y0) * seg->dxdy;
-      } else {
-	// x coord of segment endpoint with max y coord
-	xx1 = (seg->flags & splashXPathFlip) ? seg->x0 : seg->x1;
+      // intersection with top edge
+      xx0 = seg->x0 + ((SplashCoord)y - seg->y0) * seg->dxdy;
+      // intersection with bottom edge
+      xx1 = seg->x0 + ((SplashCoord)y + 1 - seg->y0) * seg->dxdy;
+      // the segment may not actually extend to the top and/or bottom edges
+      if (xx0 < xSegMin) {
+	xx0 = xSegMin;
+      } else if (xx0 > xSegMax) {
+	xx0 = xSegMax;
+      }
+      if (xx1 < xSegMin) {
+	xx1 = xSegMin;
+      } else if (xx1 > xSegMax) {
+	xx1 = xSegMax;
       }
     }
     if (xx0 < xx1) {
diff -Nur poppler.0_5_0/TODO poppler.HEAD/TODO
--- poppler.0_5_0/TODO	2005-04-05 04:49:18.000000000 +0200
+++ poppler.HEAD/TODO	2006-01-21 22:56:40.000000000 +0100
@@ -42,3 +42,13 @@
 
 	  [ This will go away again once we get the wrappers done. ]
 
+Jeff Muizelaar's TODO:
+	Short Term:
+	- factor out some of the color conversion code from CairoOutputDev and ArthurOutputDev.
+	- add CairoOutputDev::drawSoftMaskedImage. (done, but too messy)
+	- fix CairoOutputDev asking cairo to draw nonexistant glyphs.
+	- fix patterned text fills.
+	- merge kpdf's ttc support code.
+	Long Term:
+	- use cairo glyph cache for type3 fonts.
+	- try to use cairo pattern support.
diff -Nur poppler.0_5_0/utils/HtmlOutputDev.cc poppler.HEAD/utils/HtmlOutputDev.cc
--- poppler.0_5_0/utils/HtmlOutputDev.cc	2005-12-30 22:59:58.000000000 +0100
+++ poppler.HEAD/utils/HtmlOutputDev.cc	2006-01-23 16:40:54.000000000 +0100
@@ -14,6 +14,7 @@
 #pragma implementation
 #endif
 
+#include "config.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
@@ -24,7 +25,6 @@
 #include "goo/GooList.h"
 #include "UnicodeMap.h"
 #include "goo/gmem.h"
-#include "config.h"
 #include "Error.h"
 #include "GfxState.h"
 #ifdef ENABLE_LIBJPEG
@@ -33,6 +33,7 @@
 #include "GlobalParams.h"
 #include "HtmlOutputDev.h"
 #include "HtmlFonts.h"
+#include "UGooString.h"
 
 int HtmlPage::pgNum=0;
 int HtmlOutputDev::imgNum=1;
diff -Nur poppler.0_5_0/utils/ImageOutputDev.cc poppler.HEAD/utils/ImageOutputDev.cc
--- poppler.0_5_0/utils/ImageOutputDev.cc	2005-12-30 22:59:58.000000000 +0100
+++ poppler.HEAD/utils/ImageOutputDev.cc	2006-01-23 16:40:54.000000000 +0100
@@ -6,6 +6,7 @@
 //
 //========================================================================
 
+#include "config.h"
 #include <poppler-config.h>
 
 #ifdef USE_GCC_PRAGMAS
@@ -17,7 +18,6 @@
 #include <stddef.h>
 #include <ctype.h>
 #include "goo/gmem.h"
-#include "config.h"
 #include "Error.h"
 #include "GfxState.h"
 #include "Object.h"
diff -Nur poppler.0_5_0/utils/Makefile.am poppler.HEAD/utils/Makefile.am
--- poppler.0_5_0/utils/Makefile.am	2006-01-06 11:05:59.000000000 +0100
+++ poppler.HEAD/utils/Makefile.am	2006-02-23 23:26:05.000000000 +0100
@@ -13,7 +13,10 @@
 	pdfinfo					\
 	pdftops					\
 	pdftotext				\
-	pdftohtml
+	pdftohtml				\
+	$(pdftoppm_binary)
+
+EXTRA_DIST = pdf2xml.dtd
 
 dist_man1_MANS =				\
 	pdffonts.1				\
@@ -21,7 +24,9 @@
 	pdfinfo.1				\
 	pdftops.1				\
 	pdftotext.1				\
-	pdftohtml.1
+	pdftohtml.1				\
+	$(pdftoppm_manpage)
+	
 
 common = parseargs.c parseargs.h
 
@@ -56,3 +61,15 @@
 	HtmlOutputDev.cc			\
 	HtmlOutputDev.h				\
 	$(common)
+
+if BUILD_SPLASH_OUTPUT
+
+pdftoppm_SOURCES =				\
+	pdftoppm.cc				\
+	$(common)
+
+pdftoppm_binary = pdftoppm
+
+pdftoppm_manpage =pdftoppm.1
+
+endif
\ No hi ha cap carcter de salt de lnia al final del fitxer
diff -Nur poppler.0_5_0/utils/pdf2xml.dtd poppler.HEAD/utils/pdf2xml.dtd
--- poppler.0_5_0/utils/pdf2xml.dtd	1970-01-01 01:00:00.000000000 +0100
+++ poppler.HEAD/utils/pdf2xml.dtd	2006-02-04 21:31:00.000000000 +0100
@@ -0,0 +1,28 @@
+<?xml version="1.0"?>
+<!ELEMENT pdf2xml (page+)>
+<!ELEMENT page (fontspec*, text*)>
+<!ATTLIST page
+	number CDATA #REQUIRED
+	position CDATA #REQUIRED
+	top CDATA #REQUIRED
+	left CDATA #REQUIRED
+	height CDATA #REQUIRED
+	width CDATA #REQUIRED
+>
+<!ELEMENT fontspec EMPTY>
+<!ATTLIST fontspec
+	id CDATA #REQUIRED
+	size CDATA #REQUIRED
+	family CDATA #REQUIRED
+	color CDATA #REQUIRED
+>
+<!ELEMENT text (#PCDATA | b | i)*>
+<!ATTLIST text
+	top CDATA #REQUIRED
+	left CDATA #REQUIRED
+	width CDATA #REQUIRED
+	height CDATA #REQUIRED
+	font CDATA #REQUIRED
+>
+<!ELEMENT b (#PCDATA)>
+<!ELEMENT i (#PCDATA)>
diff -Nur poppler.0_5_0/utils/pdffonts.cc poppler.HEAD/utils/pdffonts.cc
--- poppler.0_5_0/utils/pdffonts.cc	2005-12-12 21:15:11.000000000 +0100
+++ poppler.HEAD/utils/pdffonts.cc	2006-01-23 16:40:54.000000000 +0100
@@ -6,6 +6,7 @@
 //
 //========================================================================
 
+#include "config.h"
 #include <poppler-config.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -22,7 +23,7 @@
 #include "GfxFont.h"
 #include "Annot.h"
 #include "PDFDoc.h"
-#include "config.h"
+#include "UGooString.h"
 
 static char *fontTypeNames[] = {
   "unknown",
diff -Nur poppler.0_5_0/utils/pdfimages.cc poppler.HEAD/utils/pdfimages.cc
--- poppler.0_5_0/utils/pdfimages.cc	2005-12-12 21:15:11.000000000 +0100
+++ poppler.HEAD/utils/pdfimages.cc	2006-01-23 16:40:54.000000000 +0100
@@ -8,6 +8,7 @@
 //
 //========================================================================
 
+#include "config.h"
 #include <poppler-config.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -27,7 +28,6 @@
 #include "PDFDoc.h"
 #include "ImageOutputDev.h"
 #include "Error.h"
-#include "config.h"
 
 static int firstPage = 1;
 static int lastPage = 0;
diff -Nur poppler.0_5_0/utils/pdfinfo.cc poppler.HEAD/utils/pdfinfo.cc
--- poppler.0_5_0/utils/pdfinfo.cc	2005-12-12 21:15:11.000000000 +0100
+++ poppler.HEAD/utils/pdfinfo.cc	2006-01-23 16:40:54.000000000 +0100
@@ -6,6 +6,7 @@
 //
 //========================================================================
 
+#include "config.h"
 #include <poppler-config.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -28,7 +29,7 @@
 #include "CharTypes.h"
 #include "UnicodeMap.h"
 #include "Error.h"
-#include "config.h"
+#include "UGooString.h"
 
 static void printInfoString(Dict *infoDict, char *key, char *text,
 			    UnicodeMap *uMap);
diff -Nur poppler.0_5_0/utils/pdftohtml.cc poppler.HEAD/utils/pdftohtml.cc
--- poppler.0_5_0/utils/pdftohtml.cc	2005-12-12 21:15:11.000000000 +0100
+++ poppler.HEAD/utils/pdftohtml.cc	2006-01-23 19:52:48.000000000 +0100
@@ -6,12 +6,13 @@
 // Copyright 1999-2000 G. Ovtcharov
 //========================================================================
 
+#include "config.h"
+#include <poppler-config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
 #include <string.h>
 #include <dirent.h>
-#include <poppler-config.h>
 #include <time.h>
 #include "parseargs.h"
 #include "goo/GooString.h"
@@ -28,7 +29,7 @@
 #include "PSOutputDev.h"
 #include "GlobalParams.h"
 #include "Error.h"
-#include "config.h"
+#include "UGooString.h"
 #include "goo/gfile.h"
 
 #ifndef GHOSTSCRIPT
@@ -315,12 +316,10 @@
     psFileName = new GooString(htmlFileName->getCString());
     psFileName->append(".ps");
 
-    globalParams->setPSPaperWidth(w);
-    globalParams->setPSPaperHeight(h);
     // XXX
     // globalParams->setPSNoText(gTrue);
     psOut = new PSOutputDev(psFileName->getCString(), doc->getXRef(),
-			    doc->getCatalog(), firstPage, lastPage, psModePS);
+			    doc->getCatalog(), firstPage, lastPage, psModePS, w, h);
     doc->displayPages(psOut, firstPage, lastPage, 72, 72, 0,
 		      gTrue, gFalse, gFalse);
     delete psOut;
diff -Nur poppler.0_5_0/utils/pdftoppm.1 poppler.HEAD/utils/pdftoppm.1
--- poppler.0_5_0/utils/pdftoppm.1	1970-01-01 01:00:00.000000000 +0100
+++ poppler.HEAD/utils/pdftoppm.1	2005-12-12 21:15:11.000000000 +0100
@@ -0,0 +1,113 @@
+.\" Copyright 2004 Glyph & Cog, LLC
+.TH pdftoppm 1 "22 January 2004"
+.SH NAME
+pdftoppm \- Portable Document Format (PDF) to Portable Pixmap (PPM)
+converter (version 3.00)
+.SH SYNOPSIS
+.B pdftoppm
+[options]
+.I PDF-file PPM-root
+.SH DESCRIPTION
+.B Pdftoppm
+converts Portable Document Format (PDF) files to color image files in
+Portable Pixmap (PPM) format, grayscale image files in Portable
+Graymap (PGM) format, or monochrome image files in Portable Bitmap
+(PBM) format.
+.PP
+Pdftoppm reads the PDF file,
+.IR PDF-file ,
+and writes one PPM file for each page,
+.IR PPM-root - nnnnnn .ppm,
+where
+.I nnnnnn
+is the page number.
+.SH CONFIGURATION FILE
+Pdftoppm reads a configuration file at startup.  It first tries to
+find the user's private config file, ~/.xpdfrc.  If that doesn't
+exist, it looks for a system-wide config file, /etc/xpdf/xpdfrc. See the
+.BR xpdfrc (5)
+man page for details.
+.SH OPTIONS
+Many of the following options can be set with configuration file
+commands.  These are listed in square brackets with the description of
+the corresponding command line option.
+.TP
+.BI \-f " number"
+Specifies the first page to convert.
+.TP
+.BI \-l " number"
+Specifies the last page to convert.
+.TP
+.BI \-r " number"
+Specifies the resolution, in DPI.  The default is 150 DPI.
+.TP
+.B \-mono
+Generate a monochrome PBM file (instead of a color PPM file).
+.TP
+.B \-gray
+Generate a grayscale PGM file (instead of a color PPM file).
+.TP
+.BI \-t1lib " yes | no"
+Enable or disable t1lib (a Type 1 font rasterizer).  This defaults to
+"yes".
+.RB "[config file: " enableT1lib ]
+.TP
+.BI \-freetype " yes | no"
+Enable or disable FreeType (a TrueType / Type 1 font rasterizer).
+This defaults to "yes".
+.RB "[config file: " enableFreeType ]
+.TP
+.BI \-aa " yes | no"
+Enable or disable font anti-aliasing.  This defaults to "yes".
+.RB "[config file: " antialias ]
+.TP
+.BI \-opw " password"
+Specify the owner password for the PDF file.  Providing this will
+bypass all security restrictions.
+.TP
+.BI \-upw " password"
+Specify the user password for the PDF file.
+.TP
+.B \-q
+Don't print any messages or errors.
+.RB "[config file: " errQuiet ]
+.TP
+.B \-v
+Print copyright and version information.
+.TP
+.B \-h
+Print usage information.
+.RB ( \-help
+and
+.B \-\-help
+are equivalent.)
+.SH EXIT CODES
+The Xpdf tools use the following exit codes:
+.TP
+0
+No error.
+.TP
+1
+Error opening a PDF file.
+.TP
+2
+Error opening an output file.
+.TP
+3
+Error related to PDF permissions.
+.TP
+99
+Other error.
+.SH AUTHOR
+The pdftoppm software and documentation are copyright 1996-2004 Glyph
+& Cog, LLC.
+.SH "SEE ALSO"
+.BR xpdf (1),
+.BR pdftops (1),
+.BR pdftotext (1),
+.BR pdfinfo (1),
+.BR pdffonts (1),
+.BR pdfimages (1),
+.BR xpdfrc (5)
+.br
+.B http://www.foolabs.com/xpdf/
diff -Nur poppler.0_5_0/utils/pdftoppm.cc poppler.HEAD/utils/pdftoppm.cc
--- poppler.0_5_0/utils/pdftoppm.cc	1970-01-01 01:00:00.000000000 +0100
+++ poppler.HEAD/utils/pdftoppm.cc	2006-02-04 21:07:08.000000000 +0100
@@ -0,0 +1,190 @@
+//========================================================================
+//
+// pdftoppm.cc
+//
+// Copyright 2003 Glyph & Cog, LLC
+//
+//========================================================================
+
+#include "config.h"
+#include <poppler-config.h>
+#include <stdio.h>
+#include "parseargs.h"
+#include "goo/gmem.h"
+#include "goo/GooString.h"
+#include "GlobalParams.h"
+#include "Object.h"
+#include "PDFDoc.h"
+#include "splash/SplashBitmap.h"
+#include "splash/Splash.h"
+#include "SplashOutputDev.h"
+
+static int firstPage = 1;
+static int lastPage = 0;
+static int resolution = 150;
+static GBool mono = gFalse;
+static GBool gray = gFalse;
+static char enableT1libStr[16] = "";
+static char enableFreeTypeStr[16] = "";
+static char antialiasStr[16] = "";
+static char ownerPassword[33] = "";
+static char userPassword[33] = "";
+static GBool quiet = gFalse;
+static char cfgFileName[256] = "";
+static GBool printVersion = gFalse;
+static GBool printHelp = gFalse;
+
+static ArgDesc argDesc[] = {
+  {"-f",      argInt,      &firstPage,     0,
+   "first page to print"},
+  {"-l",      argInt,      &lastPage,      0,
+   "last page to print"},
+  {"-r",      argInt,      &resolution,    0,
+   "resolution, in DPI (default is 150)"},
+  {"-mono",   argFlag,     &mono,          0,
+   "generate a monochrome PBM file"},
+  {"-gray",   argFlag,     &gray,          0,
+   "generate a grayscale PGM file"},
+#if HAVE_T1LIB_H
+  {"-t1lib",      argString,      enableT1libStr, sizeof(enableT1libStr),
+   "enable t1lib font rasterizer: yes, no"},
+#endif
+#if HAVE_FREETYPE_FREETYPE_H | HAVE_FREETYPE_H
+  {"-freetype",   argString,      enableFreeTypeStr, sizeof(enableFreeTypeStr),
+   "enable FreeType font rasterizer: yes, no"},
+#endif
+  {"-aa",         argString,      antialiasStr,   sizeof(antialiasStr),
+   "enable font anti-aliasing: yes, no"},
+  {"-opw",    argString,   ownerPassword,  sizeof(ownerPassword),
+   "owner password (for encrypted files)"},
+  {"-upw",    argString,   userPassword,   sizeof(userPassword),
+   "user password (for encrypted files)"},
+  {"-q",      argFlag,     &quiet,         0,
+   "don't print any messages or errors"},
+  {"-cfg",        argString,      cfgFileName,    sizeof(cfgFileName),
+   "configuration file to use in place of .xpdfrc"},
+  {"-v",      argFlag,     &printVersion,  0,
+   "print copyright and version info"},
+  {"-h",      argFlag,     &printHelp,     0,
+   "print usage information"},
+  {"-help",   argFlag,     &printHelp,     0,
+   "print usage information"},
+  {"--help",  argFlag,     &printHelp,     0,
+   "print usage information"},
+  {"-?",      argFlag,     &printHelp,     0,
+   "print usage information"},
+  {NULL}
+};
+
+int main(int argc, char *argv[]) {
+  PDFDoc *doc;
+  GooString *fileName;
+  char *ppmRoot;
+  char ppmFile[512];
+  GooString *ownerPW, *userPW;
+  SplashColor paperColor;
+  SplashOutputDev *splashOut;
+  GBool ok;
+  int exitCode;
+  int pg;
+
+  exitCode = 99;
+
+  // parse args
+  ok = parseArgs(argDesc, &argc, argv);
+  if (mono && gray) {
+    ok = gFalse;
+  }
+  if (!ok || argc != 3 || printVersion || printHelp) {
+    fprintf(stderr, "pdftoppm version %s\n", xpdfVersion);
+    fprintf(stderr, "%s\n", xpdfCopyright);
+    if (!printVersion) {
+      printUsage("pdftoppm", "<PDF-file> <PPM-root>", argDesc);
+    }
+    goto err0;
+  }
+  fileName = new GooString(argv[1]);
+  ppmRoot = argv[2];
+
+  // read config file
+  globalParams = new GlobalParams(cfgFileName);
+  if (enableT1libStr[0]) {
+    if (!globalParams->setEnableT1lib(enableT1libStr)) {
+      fprintf(stderr, "Bad '-t1lib' value on command line\n");
+    }
+  }
+  if (enableFreeTypeStr[0]) {
+    if (!globalParams->setEnableFreeType(enableFreeTypeStr)) {
+      fprintf(stderr, "Bad '-freetype' value on command line\n");
+    }
+  }
+  if (antialiasStr[0]) {
+    if (!globalParams->setAntialias(antialiasStr)) {
+      fprintf(stderr, "Bad '-aa' value on command line\n");
+    }
+  }
+  if (quiet) {
+    globalParams->setErrQuiet(quiet);
+  }
+
+  // open PDF file
+  if (ownerPassword[0]) {
+    ownerPW = new GooString(ownerPassword);
+  } else {
+    ownerPW = NULL;
+  }
+  if (userPassword[0]) {
+    userPW = new GooString(userPassword);
+  } else {
+    userPW = NULL;
+  }
+  doc = new PDFDoc(fileName, ownerPW, userPW);
+  if (userPW) {
+    delete userPW;
+  }
+  if (ownerPW) {
+    delete ownerPW;
+  }
+  if (!doc->isOk()) {
+    exitCode = 1;
+    goto err1;
+  }
+
+  // get page range
+  if (firstPage < 1)
+    firstPage = 1;
+  if (lastPage < 1 || lastPage > doc->getNumPages())
+    lastPage = doc->getNumPages();
+
+  // write PPM files
+  paperColor[0] = 255;
+  paperColor[1] = 255;
+  paperColor[2] = 255;
+  splashOut = new SplashOutputDev(mono ? splashModeMono1 :
+				    gray ? splashModeMono8 :
+				             splashModeRGB8, 4,
+				  gFalse, paperColor);
+  splashOut->startDoc(doc->getXRef());
+  for (pg = firstPage; pg <= lastPage; ++pg) {
+    doc->displayPage(splashOut, pg, resolution, resolution, 0, gTrue, gFalse, gFalse);
+    sprintf(ppmFile, "%.*s-%06d.%s",
+	    (int)sizeof(ppmFile) - 32, ppmRoot, pg,
+	    mono ? "pbm" : gray ? "pgm" : "ppm");
+    splashOut->getBitmap()->writePNMFile(ppmFile);
+  }
+  delete splashOut;
+
+  exitCode = 0;
+
+  // clean up
+ err1:
+  delete doc;
+  delete globalParams;
+ err0:
+
+  // check for memory leaks
+  Object::memCheck(stderr);
+  gMemReport(stderr);
+
+  return exitCode;
+}
diff -Nur poppler.0_5_0/utils/pdftops.cc poppler.HEAD/utils/pdftops.cc
--- poppler.0_5_0/utils/pdftops.cc	2005-12-12 21:15:11.000000000 +0100
+++ poppler.HEAD/utils/pdftops.cc	2006-01-23 19:52:48.000000000 +0100
@@ -8,6 +8,7 @@
 //
 //========================================================================
 
+#include "config.h"
 #include <poppler-config.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -27,7 +28,6 @@
 #include "PDFDoc.h"
 #include "PSOutputDev.h"
 #include "Error.h"
-#include "config.h"
 
 static int firstPage = 1;
 static int lastPage = 0;
@@ -307,7 +307,9 @@
 
   // write PostScript file
   psOut = new PSOutputDev(psFileName->getCString(), doc->getXRef(),
-			  doc->getCatalog(), firstPage, lastPage, mode);
+			  doc->getCatalog(), firstPage, lastPage, mode,
+			  globalParams->getPSPaperWidth(),
+			  globalParams->getPSPaperHeight());
   if (psOut->isOk()) {
     doc->displayPages(psOut, firstPage, lastPage, 72, 72,
 		      0, globalParams->getPSCrop(), gFalse, gFalse);
diff -Nur poppler.0_5_0/utils/pdftotext.cc poppler.HEAD/utils/pdftotext.cc
--- poppler.0_5_0/utils/pdftotext.cc	2005-12-12 21:15:11.000000000 +0100
+++ poppler.HEAD/utils/pdftotext.cc	2006-01-23 16:40:54.000000000 +0100
@@ -8,6 +8,7 @@
 //
 //========================================================================
 
+#include "config.h"
 #include <poppler-config.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -29,7 +30,7 @@
 #include "CharTypes.h"
 #include "UnicodeMap.h"
 #include "Error.h"
-#include "config.h"
+#include "UGooString.h"
 
 static void printInfoString(FILE *f, Dict *infoDict, char *key,
 			    char *text1, char *text2, UnicodeMap *uMap);
